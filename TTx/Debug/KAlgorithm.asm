; Listing generated by Microsoft (R) Optimizing Compiler Version 19.21.27702.2 

	TITLE	D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?Ori@KAlgorithm@@0PAHA				; KAlgorithm::Ori
PUBLIC	?TT@KAlgorithm@@0PAHA				; KAlgorithm::TT
_BSS	SEGMENT
?Ori@KAlgorithm@@0PAHA DD 01H DUP (?)			; KAlgorithm::Ori
?TT@KAlgorithm@@0PAHA DD 01H DUP (?)			; KAlgorithm::TT
_BSS	ENDS
msvcjmc	SEGMENT
__6C672F41_vcruntime_new@h DB 01H
__E410F33D_corecrt_math@h DB 01H
__36B85FDF_stdlib@h DB 01H
__AA918B9C_cstdlib DB 01H
__44852BD6_cmath DB 01H
__23AD7809_corecrt_stdio_config@h DB 01H
__DD74D44A_corecrt_wstdio@h DB 01H
__4B3541EE_stdio@h DB 01H
__45E68E76_type_traits DB 01H
__A2957829_malloc@h DB 01H
__2DC1B543_vcruntime_exception@h DB 01H
__A3920001_exception DB 01H
__82CA083D_corecrt_memcpy_s@h DB 01H
__F8BB3D43_corecrt_memory@h DB 01H
__61E6ED1F_corecrt_wstring@h DB 01H
__B0CBCB7B_string@h DB 01H
__990BA27D_corecrt_wconio@h DB 01H
__D837D19F_corecrt_wio@h DB 01H
__FE12CC83_corecrt_wtime@h DB 01H
__01EE68DC_stat@h DB 01H
__B513A213_wchar@h DB 01H
__1A71149F_limits DB 01H
__76C3EE5D_xutility DB 01H
__A7902F0C_xmemory0 DB 01H
__83DAEB48_xstring DB 01H
__2ADC3A5C_stdexcept DB 01H
__517AE3F8_xcall_once@h DB 01H
__EE27F1D8_system_error DB 01H
__D755614C_vcruntime_typeinfo@h DB 01H
__A6DF1811_memory DB 01H
__8A9A4F1E_xfacet DB 01H
__941D13D0_ctype@h DB 01H
__1995FE8C_xlocinfo DB 01H
__5CE49F79_xlocale DB 01H
__2070899F_xiosbase DB 01H
__C263F96E_xlocnum DB 01H
__74AB5FBC_ios DB 01H
__9C8B4319_KAlgorithm@cpp DB 01H
__2C247087_istream DB 01H
__4FF445BD_ostream DB 01H
__287C82E0_streambuf DB 01H
__9D9C0E17_utility DB 01H
__D698C119_iosfwd DB 01H
__A99E8CD7_xatomic@h DB 01H
__6A839905_xstddef DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0KAlgorithm@@AAE@XZ				; KAlgorithm::KAlgorithm
PUBLIC	??1KAlgorithm@@AAE@XZ				; KAlgorithm::~KAlgorithm
PUBLIC	?mergesort@KAlgorithm@@SAXPAHABH@Z		; KAlgorithm::mergesort
PUBLIC	?quicksort@KAlgorithm@@SAXPAHABH@Z		; KAlgorithm::quicksort
PUBLIC	?heapsort@KAlgorithm@@SAXPAHABH@Z		; KAlgorithm::heapsort
PUBLIC	?Parting@KAlgorithm@@CAXABH0@Z			; KAlgorithm::Parting
PUBLIC	?Merge@KAlgorithm@@CAXABH00@Z			; KAlgorithm::Merge
PUBLIC	?Quick@KAlgorithm@@CAXABH0@Z			; KAlgorithm::Quick
PUBLIC	?Max_heap@KAlgorithm@@CAXABH0@Z			; KAlgorithm::Max_heap
PUBLIC	?Min_heap@KAlgorithm@@CAXABH0@Z			; KAlgorithm::Min_heap
PUBLIC	?print_test@KAlgorithm@@CAXABH@Z		; KAlgorithm::print_test
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	__JustMyCode_Default
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?eof@?$char_traits@D@std@@SAHXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1KAlgorithm@@AAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 119  :         explicit __CLR_OR_THIS_CALL operator bool() const { // test if stream state okay

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 120  :             return _Ok;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 121  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 104  :         __CLR_OR_THIS_CALL ~sentry() noexcept { // destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 105  : #if _HAS_EXCEPTIONS
; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@sentry

; 107  :                 this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@sentry:

; 108  :             }
; 109  : #else // _HAS_EXCEPTIONS
; 110  :             this->_Myostr._Osfx();
; 111  : #endif // _HAS_EXCEPTIONS
; 112  :         }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 89   :             : _Sentry_base(_Ostr) { // construct locking and testing stream

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@sentry
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@sentry
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR __Ostr$[ebp]
	je	SHORT $LN2@sentry

; 91   :                 _Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@sentry:

; 92   :             }
; 93   : 
; 94   :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 95   :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv92 = -224						; size = 4
tv86 = -220						; size = 4
tv72 = -220						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 75   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@Sentry_bas

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv86[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv92[ebp], eax
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Sentry_bas:

; 78   :             }
; 79   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv93 = -212						; size = 4
tv87 = -208						; size = 4
tv73 = -208						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@Sentry_bas

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv87[ebp], ecx
	mov	edx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv87[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Sentry_bas:

; 72   :             }
; 73   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 901  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 902  :     _Ostr.put(_Ostr.widen('\n'));

	mov	esi, esp
	push	10					; 0000000aH
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 903  :     _Ostr.flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 904  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]

; 905  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
tv128 = -356						; size = 8
tv280 = -352						; size = 4
tv275 = -352						; size = 4
tv314 = -348						; size = 8
tv279 = -348						; size = 4
tv277 = -348						; size = 4
tv274 = -348						; size = 4
tv276 = -344						; size = 4
tv65 = -344						; size = 4
tv278 = -341						; size = 1
tv273 = -341						; size = 1
$T2 = -336						; size = 4
$T3 = -324						; size = 4
$T4 = -312						; size = 4
$T5 = -300						; size = 4
$T6 = -288						; size = 4
$T7 = -276						; size = 4
$T8 = -264						; size = 4
__Pad$9 = -60						; size = 8
__Ok$ = -44						; size = 8
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 741  :     basic_ostream<char, _Traits>& _Ostr, char _Ch) { // insert a char into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-356]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 742  :     using _Elem = char;
; 743  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 744  : 
; 745  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 746  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 747  : 
; 748  :     if (_Ok) { // state okay, insert

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN8@operator

; 749  :         streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv314[ebp], eax
	mov	DWORD PTR tv314[ebp+4], edx
	cmp	DWORD PTR tv314[ebp+4], 0
	jg	SHORT $LN15@operator
	jl	SHORT $LN22@operator
	cmp	DWORD PTR tv314[ebp], 1
	ja	SHORT $LN15@operator
$LN22@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv128[ebp], xmm0
	jmp	SHORT $LN16@operator
$LN15@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, 1
	sbb	edx, 0
	mov	DWORD PTR tv128[ebp], eax
	mov	DWORD PTR tv128[ebp+4], edx
$LN16@operator:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR __Pad$9[ebp], eax
	mov	ecx, DWORD PTR tv128[ebp+4]
	mov	DWORD PTR __Pad$9[ebp+4], ecx

; 750  : 
; 751  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 752  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN10@operator

; 753  :             for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR __Pad$9[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$9[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$9[ebp], eax
	mov	DWORD PTR __Pad$9[ebp+4], ecx
$LN4@operator:
	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN10@operator
	cmp	DWORD PTR __Pad$9[ebp+4], 0
	jl	$LN10@operator
	jg	SHORT $LN23@operator
	cmp	DWORD PTR __Pad$9[ebp], 0
	jbe	$LN10@operator
$LN23@operator:

; 754  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv273[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv274[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv273[ebp]
	push	eax
	mov	ecx, DWORD PTR tv274[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv275[ebp], eax
	mov	ecx, DWORD PTR tv275[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T7[ebp], eax
	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@operator

; 755  :                     _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN11@operator:

; 756  :                 }
; 757  :             }

	jmp	$LN2@operator
$LN10@operator:

; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN12@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv276[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv276[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv277[ebp], eax
	mov	ecx, DWORD PTR tv277[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@operator

; 761  :             _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN12@operator:

; 762  :         }
; 763  : 
; 764  :         for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR __Pad$9[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$9[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$9[ebp], eax
	mov	DWORD PTR __Pad$9[ebp+4], ecx
$LN7@operator:
	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN6@operator
	cmp	DWORD PTR __Pad$9[ebp+4], 0
	jl	$LN6@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR __Pad$9[ebp], 0
	jbe	$LN6@operator
$LN24@operator:

; 765  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv278[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv279[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv278[ebp]
	push	eax
	mov	ecx, DWORD PTR tv279[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv280[ebp], eax
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@operator

; 766  :                 _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN13@operator:

; 767  :             }
; 768  :         }

	jmp	$LN5@operator
$LN6@operator:
	jmp	SHORT $LN17@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:

; 769  :         _CATCH_IO_(ios_base, _Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN21@operator
	ret	0
$LN17@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN8@operator
$LN21@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN8@operator:

; 770  :     }
; 771  : 
; 772  :     _Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 773  :     _Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 774  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 775  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@operator:
	DD	1
	DD	$LN27@operator
$LN27@operator:
	DD	-44					; ffffffd4H
	DD	8
	DD	$LN25@operator
$LN25@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xstring
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 373  :     _NODISCARD static constexpr int_type eof() noexcept { // return end-of-file metacharacter

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eof@?$char_traits@D@std@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __83DAEB48_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 374  :         return EOF;

	or	eax, -1

; 375  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?eof@?$char_traits@D@std@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eof@?$char_traits@D@std@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xstring
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 365  :         const int_type& _Left, const int_type& _Right) noexcept { // test for metacharacter equality

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __83DAEB48_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 366  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	mov	al, BYTE PTR tv65[ebp]

; 367  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?print_test@KAlgorithm@@CAXABH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
__Size$ = 8						; size = 4
?print_test@KAlgorithm@@CAXABH@Z PROC			; KAlgorithm::print_test, COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 225  : 	for (int i = 0; i < _Size; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@print_test
$LN2@print_test:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@print_test:
	mov	eax, DWORD PTR __Size$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@print_test

; 226  : 	{
; 227  : 		std::cout << Ori[i] << ' ';

	push	32					; 00000020H
	mov	esi, esp
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 228  : 	}

	jmp	SHORT $LN2@print_test
$LN3@print_test:

; 229  : 
; 230  : 	std::cout << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?print_test@KAlgorithm@@CAXABH@Z ENDP			; KAlgorithm::print_test
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?Min_heap@KAlgorithm@@CAXABH0@Z
_TEXT	SEGMENT
__Start$ = 8						; size = 4
__End$ = 12						; size = 4
?Min_heap@KAlgorithm@@CAXABH0@Z PROC			; KAlgorithm::Min_heap, COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 218  : 
; 219  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Min_heap@KAlgorithm@@CAXABH0@Z ENDP			; KAlgorithm::Min_heap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?Max_heap@KAlgorithm@@CAXABH0@Z
_TEXT	SEGMENT
_c$1 = -92						; size = 4
_root$2 = -80						; size = 4
_tmp$3 = -68						; size = 4
_i$4 = -56						; size = 4
_Tmp$5 = -44						; size = 4
_root$6 = -32						; size = 4
_idx$7 = -20						; size = 4
_i$8 = -8						; size = 4
__Start$ = 8						; size = 4
__End$ = 12						; size = 4
?Max_heap@KAlgorithm@@CAXABH0@Z PROC			; KAlgorithm::Max_heap, COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 162  : 	// 이진화 - 트리구조 정렬 - 루트 찾기
; 163  : 	// 일차적인 이진트리 구현
; 164  : 	for (int i = _Start; i < _End; i++)

	mov	eax, DWORD PTR __Start$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$8[ebp], ecx
	jmp	SHORT $LN4@Max_heap
$LN2@Max_heap:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN4@Max_heap:
	mov	eax, DWORD PTR __End$[ebp]
	mov	ecx, DWORD PTR _i$8[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@Max_heap

; 165  : 	{
; 166  : 		int idx = i;

	mov	eax, DWORD PTR _i$8[ebp]
	mov	DWORD PTR _idx$7[ebp], eax
$LN7@Max_heap:

; 167  : 		do
; 168  : 		{
; 169  : 			// 현재를 루트로 보고 있는 것
; 170  : 			int root = (idx - 1) / 2;

	mov	eax, DWORD PTR _idx$7[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _root$6[ebp], eax

; 171  : 			if (Ori[root] < Ori[idx])

	mov	eax, DWORD PTR _root$6[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _idx$7[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jge	SHORT $LN14@Max_heap

; 172  : 			{
; 173  : 				int Tmp = Ori[root];

	mov	eax, DWORD PTR _root$6[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _Tmp$5[ebp], edx

; 174  : 				Ori[root] = Ori[idx];

	mov	eax, DWORD PTR _root$6[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _idx$7[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 175  : 				Ori[idx] = Tmp;

	mov	eax, DWORD PTR _idx$7[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _Tmp$5[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$LN14@Max_heap:

; 176  : 			}
; 177  : 			idx = root;

	mov	eax, DWORD PTR _root$6[ebp]
	mov	DWORD PTR _idx$7[ebp], eax

; 178  : 		} while (idx != 0);

	cmp	DWORD PTR _idx$7[ebp], 0
	jne	SHORT $LN7@Max_heap

; 179  : 	}

	jmp	$LN2@Max_heap
$LN3@Max_heap:

; 180  : 
; 181  : 	for (int i = _End - 1; i >= 0; --i)

	mov	eax, DWORD PTR __End$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$4[ebp], ecx
	jmp	SHORT $LN10@Max_heap
$LN8@Max_heap:
	mov	eax, DWORD PTR _i$4[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN10@Max_heap:
	cmp	DWORD PTR _i$4[ebp], 0
	jl	$LN1@Max_heap

; 182  : 	{
; 183  : 		// 루트 설정 -> 루트를 제일 뒤로 보내는 작업
; 184  : 		int tmp = Ori[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _tmp$3[ebp], eax

; 185  : 		Ori[0] = Ori[i];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	eax, DWORD PTR _i$4[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx], eax

; 186  : 		Ori[i] = tmp;

	mov	eax, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _tmp$3[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 187  : 
; 188  : 
; 189  : 		int root = 0;

	mov	DWORD PTR _root$2[ebp], 0

; 190  : 		int c = 1;

	mov	DWORD PTR _c$1[ebp], 1
$LN13@Max_heap:

; 191  : 	
; 192  : 		
; 193  : 		// 재 이진 트리 구현
; 194  : 		do
; 195  : 		{
; 196  : 			// 부모 노드 설정 - 부모노드 * 2 + 1 = 부모노드 왼쪽, + 2 오른쪽
; 197  : 			c = 2 * root + 1;

	mov	eax, DWORD PTR _root$2[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	mov	DWORD PTR _c$1[ebp], ecx

; 198  : 
; 199  : 			if (c < i - 1 && Ori[c] < Ori[c +1])

	mov	eax, DWORD PTR _i$4[ebp]
	sub	eax, 1
	cmp	DWORD PTR _c$1[ebp], eax
	jge	SHORT $LN15@Max_heap
	mov	eax, DWORD PTR _c$1[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _c$1[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4+4]
	jge	SHORT $LN15@Max_heap

; 200  : 			{
; 201  : 				++c;

	mov	eax, DWORD PTR _c$1[ebp]
	add	eax, 1
	mov	DWORD PTR _c$1[ebp], eax
$LN15@Max_heap:

; 202  : 			}
; 203  : 
; 204  : 			if (c < i && Ori[root] < Ori [c])

	mov	eax, DWORD PTR _c$1[ebp]
	cmp	eax, DWORD PTR _i$4[ebp]
	jge	SHORT $LN16@Max_heap
	mov	eax, DWORD PTR _root$2[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _c$1[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jge	SHORT $LN16@Max_heap

; 205  : 			{
; 206  : 				tmp = Ori[root];

	mov	eax, DWORD PTR _root$2[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _tmp$3[ebp], edx

; 207  : 				Ori[root] = Ori[c];

	mov	eax, DWORD PTR _root$2[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _c$1[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 208  : 				Ori[c] = tmp;

	mov	eax, DWORD PTR _c$1[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _tmp$3[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$LN16@Max_heap:

; 209  : 			}
; 210  : 
; 211  : 			root = c;

	mov	eax, DWORD PTR _c$1[ebp]
	mov	DWORD PTR _root$2[ebp], eax

; 212  : 		} while (c < i);

	mov	eax, DWORD PTR _c$1[ebp]
	cmp	eax, DWORD PTR _i$4[ebp]
	jl	$LN13@Max_heap

; 213  : 	}

	jmp	$LN8@Max_heap
$LN1@Max_heap:

; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Max_heap@KAlgorithm@@CAXABH0@Z ENDP			; KAlgorithm::Max_heap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?Quick@KAlgorithm@@CAXABH0@Z
_TEXT	SEGMENT
_Tmp$ = -48						; size = 4
_Right$ = -36						; size = 4
_Left$ = -24						; size = 4
_Pivot$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Start$ = 8						; size = 4
__End$ = 12						; size = 4
?Quick@KAlgorithm@@CAXABH0@Z PROC			; KAlgorithm::Quick, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 109  : 	int Pivot = (_End + _Start) / 2;

	mov	eax, DWORD PTR __End$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Start$[ebp]
	add	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _Pivot$[ebp], eax

; 110  : 	int Left = _Start;

	mov	eax, DWORD PTR __Start$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Left$[ebp], ecx

; 111  : 	int Right = _End;

	mov	eax, DWORD PTR __End$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Right$[ebp], ecx
$LN5@Quick:

; 112  : 	int Tmp;
; 113  : 
; 114  : 
; 115  : 	do
; 116  : 	{
; 117  : 		// 피봇을 만날 때까지 왼쪽 인덱스와 오른쪽 인덱스를 땡긴다.
; 118  : 		while (Ori[Left] < Ori[Pivot])

	mov	eax, DWORD PTR _Left$[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _Pivot$[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jge	SHORT $LN7@Quick

; 119  : 		{
; 120  : 			++Left;

	mov	eax, DWORD PTR _Left$[ebp]
	add	eax, 1
	mov	DWORD PTR _Left$[ebp], eax

; 121  : 		}

	jmp	SHORT $LN5@Quick
$LN7@Quick:

; 122  : 		while (Ori[Right] > Ori[Pivot])

	mov	eax, DWORD PTR _Right$[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _Pivot$[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jle	SHORT $LN8@Quick

; 123  : 		{
; 124  : 			--Right;

	mov	eax, DWORD PTR _Right$[ebp]
	sub	eax, 1
	mov	DWORD PTR _Right$[ebp], eax

; 125  : 		}

	jmp	SHORT $LN7@Quick
$LN8@Quick:

; 126  : 
; 127  : 		// 왼쪽 인덱스가 값이 더 클 경우 바꾸어준다.
; 128  : 		if (Left <= Right)

	mov	eax, DWORD PTR _Left$[ebp]
	cmp	eax, DWORD PTR _Right$[ebp]
	jg	SHORT $LN2@Quick

; 129  : 		{
; 130  : 			Tmp = Ori[Left];

	mov	eax, DWORD PTR _Left$[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _Tmp$[ebp], edx

; 131  : 			Ori[Left] = Ori[Right];

	mov	eax, DWORD PTR _Left$[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _Right$[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 132  : 			Ori[Right] = Tmp;

	mov	eax, DWORD PTR _Right$[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _Tmp$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 133  : 
; 134  : 			++Left;

	mov	eax, DWORD PTR _Left$[ebp]
	add	eax, 1
	mov	DWORD PTR _Left$[ebp], eax

; 135  : 			--Right;

	mov	eax, DWORD PTR _Right$[ebp]
	sub	eax, 1
	mov	DWORD PTR _Right$[ebp], eax
$LN2@Quick:

; 136  : 		}
; 137  : 	} while (Left <= Right);

	mov	eax, DWORD PTR _Left$[ebp]
	cmp	eax, DWORD PTR _Right$[ebp]
	jle	$LN5@Quick

; 138  : 
; 139  : 	   	  
; 140  : 	if (Left < _End)

	mov	eax, DWORD PTR __End$[ebp]
	mov	ecx, DWORD PTR _Left$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN10@Quick

; 141  : 	{
; 142  : 		Quick(Left, _End);

	mov	eax, DWORD PTR __End$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Left$[ebp]
	push	ecx
	call	?Quick@KAlgorithm@@CAXABH0@Z		; KAlgorithm::Quick
	add	esp, 8
$LN10@Quick:

; 143  : 	}
; 144  : 
; 145  : 	if (Right > _Start)

	mov	eax, DWORD PTR __Start$[ebp]
	mov	ecx, DWORD PTR _Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN1@Quick

; 146  : 	{
; 147  : 		Quick(_Start, Right);

	lea	eax, DWORD PTR _Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Start$[ebp]
	push	ecx
	call	?Quick@KAlgorithm@@CAXABH0@Z		; KAlgorithm::Quick
	add	esp, 8
$LN1@Quick:

; 148  : 	}
; 149  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@Quick
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN16@Quick:
	DD	2
	DD	$LN15@Quick
$LN15@Quick:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN13@Quick
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN14@Quick
$LN14@Quick:
	DB	82					; 00000052H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	0
$LN13@Quick:
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	116					; 00000074H
	DB	0
?Quick@KAlgorithm@@CAXABH0@Z ENDP			; KAlgorithm::Quick
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?Merge@KAlgorithm@@CAXABH00@Z
_TEXT	SEGMENT
_Tmp$ = -56						; size = 4
_IDX$ = -44						; size = 4
_X2$ = -32						; size = 4
_X1$ = -20						; size = 4
_i$1 = -8						; size = 4
__Start$ = 8						; size = 4
__Mid$ = 12						; size = 4
__End$ = 16						; size = 4
?Merge@KAlgorithm@@CAXABH00@Z PROC			; KAlgorithm::Merge, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 50   : 	for (int i = _Start; i <= _End; ++i)

	mov	eax, DWORD PTR __Start$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@Merge
$LN2@Merge:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@Merge:
	mov	eax, DWORD PTR __End$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jg	SHORT $LN3@Merge

; 51   : 	{
; 52   : 		TT[i] = Ori[i];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR ?TT@KAlgorithm@@0PAHA	; KAlgorithm::TT
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 53   : 	}

	jmp	SHORT $LN2@Merge
$LN3@Merge:

; 54   : 
; 55   : 	// 마련된 공간에 비교하는 인덱스 위치
; 56   : 	int X1 = _Start;

	mov	eax, DWORD PTR __Start$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _X1$[ebp], ecx

; 57   : 	int X2 = _Mid + 1;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	DWORD PTR _X2$[ebp], ecx

; 58   : 
; 59   : 	// 지정 공간이 채워지는 인덱스
; 60   : 	int IDX = _Start;

	mov	eax, DWORD PTR __Start$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _IDX$[ebp], ecx

; 61   : 	int Tmp = 0;

	mov	DWORD PTR _Tmp$[ebp], 0
$LN5@Merge:

; 62   : 
; 63   : 	while (X1 <= _Mid && X2 <= _End)

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR _X1$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jg	SHORT $LN6@Merge
	mov	eax, DWORD PTR __End$[ebp]
	mov	ecx, DWORD PTR _X2$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jg	SHORT $LN6@Merge

; 64   : 	{
; 65   : 		if (TT[X1] > TT[X2])

	mov	eax, DWORD PTR _X1$[ebp]
	mov	ecx, DWORD PTR ?TT@KAlgorithm@@0PAHA	; KAlgorithm::TT
	mov	edx, DWORD PTR _X2$[ebp]
	mov	esi, DWORD PTR ?TT@KAlgorithm@@0PAHA	; KAlgorithm::TT
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jle	SHORT $LN10@Merge

; 66   : 		{
; 67   : 			Ori[IDX] = TT[X2];

	mov	eax, DWORD PTR _IDX$[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _X2$[ebp]
	mov	esi, DWORD PTR ?TT@KAlgorithm@@0PAHA	; KAlgorithm::TT
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 68   : 			++X2;

	mov	eax, DWORD PTR _X2$[ebp]
	add	eax, 1
	mov	DWORD PTR _X2$[ebp], eax

; 69   : 		}
; 70   : 		else

	jmp	SHORT $LN11@Merge
$LN10@Merge:

; 71   : 		{
; 72   : 			Ori[IDX] = TT[X1];

	mov	eax, DWORD PTR _IDX$[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _X1$[ebp]
	mov	esi, DWORD PTR ?TT@KAlgorithm@@0PAHA	; KAlgorithm::TT
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 73   : 			++X1;

	mov	eax, DWORD PTR _X1$[ebp]
	add	eax, 1
	mov	DWORD PTR _X1$[ebp], eax
$LN11@Merge:

; 74   : 		}
; 75   : 		++IDX;

	mov	eax, DWORD PTR _IDX$[ebp]
	add	eax, 1
	mov	DWORD PTR _IDX$[ebp], eax

; 76   : 	}

	jmp	SHORT $LN5@Merge
$LN6@Merge:

; 77   : 
; 78   : 	// 남아있는 메모리 공간
; 79   : 	// While문이 인덱스 조건이 아닌 임시 인덱스 이기 때문에
; 80   : 	// 비교 중 빠져나올 수 있다. 이는 남아있는 임시 보관소에 비교가 되지 않는
; 81   : 	// 부분이 존재한다는 것
; 82   : 	// 뒤쪽에서 남아있는 경우는 어차피 원본에서 복사한 형태이기 때문에
; 83   : 	// 뒤쪽은 정렬이 되어있는 경우이다.
; 84   : 	for (; X1 <= _Mid; ++X1)

	jmp	SHORT $LN9@Merge
$LN7@Merge:
	mov	eax, DWORD PTR _X1$[ebp]
	add	eax, 1
	mov	DWORD PTR _X1$[ebp], eax
$LN9@Merge:
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR _X1$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jg	SHORT $LN1@Merge

; 85   : 	{
; 86   : 		Ori[IDX] = TT[X1];

	mov	eax, DWORD PTR _IDX$[ebp]
	mov	ecx, DWORD PTR ?Ori@KAlgorithm@@0PAHA	; KAlgorithm::Ori
	mov	edx, DWORD PTR _X1$[ebp]
	mov	esi, DWORD PTR ?TT@KAlgorithm@@0PAHA	; KAlgorithm::TT
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 87   : 		++IDX;

	mov	eax, DWORD PTR _IDX$[ebp]
	add	eax, 1
	mov	DWORD PTR _IDX$[ebp], eax

; 88   : 	}

	jmp	SHORT $LN7@Merge
$LN1@Merge:

; 89   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Merge@KAlgorithm@@CAXABH00@Z ENDP			; KAlgorithm::Merge
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?Parting@KAlgorithm@@CAXABH0@Z
_TEXT	SEGMENT
$T1 = -216						; size = 4
_mid$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Start$ = 8						; size = 4
__End$ = 12						; size = 4
?Parting@KAlgorithm@@CAXABH0@Z PROC			; KAlgorithm::Parting, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 36   : 	int mid = (_Start + _End) / 2;

	mov	eax, DWORD PTR __Start$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR __End$[ebp]
	add	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _mid$[ebp], eax

; 37   : 
; 38   : 	if (_Start < _End)

	mov	eax, DWORD PTR __Start$[ebp]
	mov	ecx, DWORD PTR __End$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN1@Parting

; 39   : 	{
; 40   : 		Parting(_Start, mid);

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Start$[ebp]
	push	ecx
	call	?Parting@KAlgorithm@@CAXABH0@Z		; KAlgorithm::Parting
	add	esp, 8

; 41   : 		Parting(mid + 1, _End);

	mov	eax, DWORD PTR _mid$[ebp]
	add	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR __End$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	?Parting@KAlgorithm@@CAXABH0@Z		; KAlgorithm::Parting
	add	esp, 8

; 42   : 		Merge(_Start, mid, _End);

	mov	eax, DWORD PTR __End$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Start$[ebp]
	push	edx
	call	?Merge@KAlgorithm@@CAXABH00@Z		; KAlgorithm::Merge
	add	esp, 12					; 0000000cH
$LN1@Parting:

; 43   : 	}
; 44   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Parting
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@Parting:
	DD	1
	DD	$LN5@Parting
$LN5@Parting:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN4@Parting
$LN4@Parting:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
?Parting@KAlgorithm@@CAXABH0@Z ENDP			; KAlgorithm::Parting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?heapsort@KAlgorithm@@SAXPAHABH@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
$T2 = -200						; size = 4
__Arr$ = 8						; size = 4
__Size$ = 12						; size = 4
?heapsort@KAlgorithm@@SAXPAHABH@Z PROC			; KAlgorithm::heapsort, COMDAT

; 155  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 156  : 	Ori = _Arr;

	mov	eax, DWORD PTR __Arr$[ebp]
	mov	DWORD PTR ?Ori@KAlgorithm@@0PAHA, eax	; KAlgorithm::Ori

; 157  : 	Max_heap(0, _Size - 1);

	mov	eax, DWORD PTR __Size$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?Max_heap@KAlgorithm@@CAXABH0@Z		; KAlgorithm::Max_heap
	add	esp, 8

; 158  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?heapsort@KAlgorithm@@SAXPAHABH@Z ENDP			; KAlgorithm::heapsort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?quicksort@KAlgorithm@@SAXPAHABH@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
$T2 = -200						; size = 4
__Arr$ = 8						; size = 4
__Size$ = 12						; size = 4
?quicksort@KAlgorithm@@SAXPAHABH@Z PROC			; KAlgorithm::quicksort, COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 100  : 	Ori = _Arr;

	mov	eax, DWORD PTR __Arr$[ebp]
	mov	DWORD PTR ?Ori@KAlgorithm@@0PAHA, eax	; KAlgorithm::Ori

; 101  : 
; 102  : 	// 마지막이 피벗인데 난수가 원래 구성이긴 하지만
; 103  : 	// 보통 가운데서 나뉜다는 설명이 주를 이룸 - 안정성을 위해 가운데서 나누는 형식
; 104  : 	Quick(0, _Size - 1);

	mov	eax, DWORD PTR __Size$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?Quick@KAlgorithm@@CAXABH0@Z		; KAlgorithm::Quick
	add	esp, 8

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?quicksort@KAlgorithm@@SAXPAHABH@Z ENDP			; KAlgorithm::quicksort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?mergesort@KAlgorithm@@SAXPAHABH@Z
_TEXT	SEGMENT
tv79 = -244						; size = 4
$T1 = -236						; size = 4
$T2 = -224						; size = 4
$T3 = -212						; size = 4
$T4 = -200						; size = 4
__Arr$ = 8						; size = 4
__Size$ = 12						; size = 4
?mergesort@KAlgorithm@@SAXPAHABH@Z PROC			; KAlgorithm::mergesort, COMDAT

; 24   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 25   : 	Ori = _Arr;

	mov	eax, DWORD PTR __Arr$[ebp]
	mov	DWORD PTR ?Ori@KAlgorithm@@0PAHA, eax	; KAlgorithm::Ori

; 26   : 	TT = new int[_Size];

	xor	ecx, ecx
	mov	edx, DWORD PTR __Size$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR ?TT@KAlgorithm@@0PAHA, eax	; KAlgorithm::TT

; 27   : 	Parting(0, _Size - 1);

	mov	eax, DWORD PTR __Size$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?Parting@KAlgorithm@@CAXABH0@Z		; KAlgorithm::Parting
	add	esp, 8

; 28   : 	delete[] TT;

	mov	eax, DWORD PTR ?TT@KAlgorithm@@0PAHA	; KAlgorithm::TT
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	cmp	DWORD PTR $T1[ebp], 0
	jne	SHORT $LN3@mergesort
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN1@mergesort
$LN3@mergesort:
	mov	DWORD PTR ?TT@KAlgorithm@@0PAHA, 33059	; KAlgorithm::TT, 00008123H
	mov	edx, DWORD PTR ?TT@KAlgorithm@@0PAHA	; KAlgorithm::TT
	mov	DWORD PTR tv79[ebp], edx
$LN1@mergesort:

; 29   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?mergesort@KAlgorithm@@SAXPAHABH@Z ENDP			; KAlgorithm::mergesort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ??1KAlgorithm@@AAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1KAlgorithm@@AAE@XZ PROC				; KAlgorithm::~KAlgorithm, COMDAT
; _this$ = ecx

; 10   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1KAlgorithm@@AAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 11   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1KAlgorithm@@AAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1KAlgorithm@@AAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1KAlgorithm@@AAE@XZ ENDP				; KAlgorithm::~KAlgorithm
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ??0KAlgorithm@@AAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0KAlgorithm@@AAE@XZ PROC				; KAlgorithm::KAlgorithm, COMDAT
; _this$ = ecx

; 6    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 7    : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0KAlgorithm@@AAE@XZ ENDP				; KAlgorithm::KAlgorithm
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\KAlgorithm.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9C8B4319_KAlgorithm@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
