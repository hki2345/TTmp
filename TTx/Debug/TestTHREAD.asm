; Listing generated by Microsoft (R) Optimizing Compiler Version 19.21.27702.2 

	TITLE	D:\Class\6.0\TTx\TTx\TestTHREAD.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__23AD7809_corecrt_stdio_config@h DB 01H
__DD74D44A_corecrt_wstdio@h DB 01H
__4B3541EE_stdio@h DB 01H
__82CA083D_corecrt_memcpy_s@h DB 01H
__990BA27D_corecrt_wconio@h DB 01H
__D837D19F_corecrt_wio@h DB 01H
__61E6ED1F_corecrt_wstring@h DB 01H
__FE12CC83_corecrt_wtime@h DB 01H
__01EE68DC_stat@h DB 01H
__B513A213_wchar@h DB 01H
__E410F33D_corecrt_math@h DB 01H
__36B85FDF_stdlib@h DB 01H
__AA918B9C_cstdlib DB 01H
__1A71149F_limits DB 01H
__45E68E76_type_traits DB 01H
__2836B278_ratio DB 01H
__6C672F41_vcruntime_new@h DB 01H
__B62FE6C9_time@h DB 01H
__7E9C1215_chrono DB 01H
__A2957829_malloc@h DB 01H
__2DC1B543_vcruntime_exception@h DB 01H
__A3920001_exception DB 01H
__F8BB3D43_corecrt_memory@h DB 01H
__B0CBCB7B_string@h DB 01H
__76C3EE5D_xutility DB 01H
__A7902F0C_xmemory0 DB 01H
__83DAEB48_xstring DB 01H
__2ADC3A5C_stdexcept DB 01H
__517AE3F8_xcall_once@h DB 01H
__EE27F1D8_system_error DB 01H
__D755614C_vcruntime_typeinfo@h DB 01H
__A6DF1811_memory DB 01H
__7081408F_xthreads@h DB 01H
__E2A63297_tuple DB 01H
__7D9260A7_thread DB 01H
__3A9BB828_mutex DB 01H
__44852BD6_cmath DB 01H
__8A9A4F1E_xfacet DB 01H
__941D13D0_ctype@h DB 01H
__1995FE8C_xlocinfo DB 01H
__5CE49F79_xlocale DB 01H
__2070899F_xiosbase DB 01H
__C263F96E_xlocnum DB 01H
__74AB5FBC_ios DB 01H
__1D59C813_TestTHREAD@h DB 01H
__873FF162_TestTHREAD@cpp DB 01H
__2C247087_istream DB 01H
__4FF445BD_ostream DB 01H
__287C82E0_streambuf DB 01H
__9D9C0E17_utility DB 01H
__D698C119_iosfwd DB 01H
__A99E8CD7_xatomic@h DB 01H
__6A839905_xstddef DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
PUBLIC	??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
PUBLIC	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?_Check_C_return@std@@YAHH@Z			; std::_Check_C_return
PUBLIC	??1thread@std@@QAE@XZ				; std::thread::~thread
PUBLIC	?joinable@thread@std@@QBE_NXZ			; std::thread::joinable
PUBLIC	?join@thread@std@@QAEXXZ			; std::thread::join
PUBLIC	??0_Mutex_base@std@@QAE@H@Z			; std::_Mutex_base::_Mutex_base
PUBLIC	??1_Mutex_base@std@@QAE@XZ			; std::_Mutex_base::~_Mutex_base
PUBLIC	?lock@_Mutex_base@std@@QAEXXZ			; std::_Mutex_base::lock
PUBLIC	?unlock@_Mutex_base@std@@QAEXXZ			; std::_Mutex_base::unlock
PUBLIC	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
PUBLIC	??0mutex@std@@QAE@XZ				; std::mutex::mutex
PUBLIC	??1mutex@std@@QAE@XZ				; std::mutex::~mutex
PUBLIC	??0?$lock_guard@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ; std::lock_guard<std::mutex>::lock_guard<std::mutex>
PUBLIC	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ	; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
PUBLIC	?T1@C1@@EAEXXZ					; C1::T1
PUBLIC	?T2@C1@@EAEXXZ					; C1::T2
PUBLIC	??0C1@@QAE@XZ					; C1::C1
PUBLIC	??1C1@@QAE@XZ					; C1::~C1
PUBLIC	_main
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>
PUBLIC	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
PUBLIC	??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<<lambda_463439238b6f21205974601aef348251> >,0>
PUBLIC	??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,0>
PUBLIC	??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
PUBLIC	??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >
PUBLIC	??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>
PUBLIC	??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>
PUBLIC	??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>
PUBLIC	??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>
PUBLIC	??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>
PUBLIC	??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>
PUBLIC	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
PUBLIC	__JustMyCode_Default
PUBLIC	??_7C1@@6B@					; C1::`vftable'
PUBLIC	??_C@_0BB@LMHBLPIB@1?4?5Acquiring?5m1?4@	; `string'
PUBLIC	??_C@_0BA@OAMHMFLN@1?4?5Acquiring?5m2@		; `string'
PUBLIC	??_C@_0BA@MJAPHBEP@2?4?5Acquiring?5m2@		; `string'
PUBLIC	??_C@_0BA@OCCCCCIM@2?4?5Acquiring?5m1@		; `string'
PUBLIC	??_R4C1@@6B@					; C1::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVC1@@@8					; C1 `RTTI Type Descriptor'
PUBLIC	??_R3C1@@8					; C1::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2C1@@8					; C1::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@C1@@8				; C1::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@412a5e0000000000
PUBLIC	__real@41cdcd6500000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__Xtime_get_ticks:PROC
EXTRN	__Query_perf_counter:PROC
EXTRN	__Query_perf_frequency:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__imp__terminate:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___beginthreadex:PROC
EXTRN	__Thrd_join:PROC
EXTRN	__Thrd_sleep:PROC
EXTRN	__Thrd_id:PROC
EXTRN	__Mtx_init_in_situ:PROC
EXTRN	__Mtx_destroy_in_situ:PROC
EXTRN	__Mtx_lock:PROC
EXTRN	__Mtx_unlock:PROC
EXTRN	__Cnd_do_broadcast_at_thread_exit:PROC
EXTRN	?_Throw_C_error@std@@YAXH@Z:PROC		; std::_Throw_C_error
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__allrem:PROC
EXTRN	__ltod3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+09
CONST	ENDS
;	COMDAT __real@412a5e0000000000
CONST	SEGMENT
__real@412a5e0000000000 DQ 0412a5e0000000000r	; 864000
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@C1@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@C1@@8 DD FLAT:??_R0?AVC1@@@8		; C1::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3C1@@8
rdata$r	ENDS
;	COMDAT ??_R2C1@@8
rdata$r	SEGMENT
??_R2C1@@8 DD	FLAT:??_R1A@?0A@EA@C1@@8		; C1::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3C1@@8
rdata$r	SEGMENT
??_R3C1@@8 DD	00H					; C1::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2C1@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVC1@@@8
data$r	SEGMENT
??_R0?AVC1@@@8 DD FLAT:??_7type_info@@6B@		; C1 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVC1@@', 00H
data$r	ENDS
;	COMDAT ??_R4C1@@6B@
rdata$r	SEGMENT
??_R4C1@@6B@ DD	00H					; C1::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVC1@@@8
	DD	FLAT:??_R3C1@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@OCCCCCIM@2?4?5Acquiring?5m1@
CONST	SEGMENT
??_C@_0BA@OCCCCCIM@2?4?5Acquiring?5m1@ DB '2. Acquiring m1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJAPHBEP@2?4?5Acquiring?5m2@
CONST	SEGMENT
??_C@_0BA@MJAPHBEP@2?4?5Acquiring?5m2@ DB '2. Acquiring m2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OAMHMFLN@1?4?5Acquiring?5m2@
CONST	SEGMENT
??_C@_0BA@OAMHMFLN@1?4?5Acquiring?5m2@ DB '1. Acquiring m2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMHBLPIB@1?4?5Acquiring?5m1?4@
CONST	SEGMENT
??_C@_0BB@LMHBLPIB@1?4?5Acquiring?5m1?4@ DB '1. Acquiring m1.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7C1@@6B@
CONST	SEGMENT
??_7C1@@6B@ DD	FLAT:??_R4C1@@6B@			; C1::`vftable'
	DD	FLAT:?T1@C1@@EAEXXZ
	DD	FLAT:?T2@C1@@EAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$move@AAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$get@$0A@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YAAAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$move@AAV<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$get@$0A@V<lambda_463439238b6f21205974601aef348251>@@@std@@YAAAV<lambda_463439238b6f21205974601aef348251>@@AAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?release@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?get@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??R?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?release@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?get@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??R?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z$0
__ehfuncinfo$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ$1
__ehfuncinfo$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z$0
__ehfuncinfo$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ$1
__ehfuncinfo$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	01H
	DD	FLAT:__unwindfunclet$_main$2
	DD	02H
	DD	FLAT:__unwindfunclet$_main$3
	DD	03H
	DD	FLAT:__unwindfunclet$_main$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1C1@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0mutex@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Mutex_base@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Mutex_base@std@@QAE@H@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?joinable@thread@std@@QBE_NXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1thread@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?eof@?$char_traits@D@std@@SAHXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?length@?$char_traits@D@std@@SAIQBD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [eax], xmm0

; 77   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
tv93 = -424						; size = 4
tv128 = -420						; size = 4
tv131 = -416						; size = 4
$T1 = -408						; size = 8
$T2 = -392						; size = 8
$T3 = -376						; size = 8
$T4 = -360						; size = 8
$T5 = -344						; size = 4
$T6 = -332						; size = 8
$T7 = -316						; size = 8
$T8 = -300						; size = 8
$T9 = -284						; size = 4
$T10 = -272						; size = 8
$T11 = -256						; size = 8
$T12 = -240						; size = 8
$T13 = -224						; size = 4
__Den_is_one$ = -17					; size = 1
__Num_is_one$ = -5					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>, COMDAT

; 364  :         const duration<_Rep, _Period>& _Dur) { // convert duration to another duration; truncate

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-424]
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;

	mov	BYTE PTR __Num_is_one$[ebp], 1

; 371  :         constexpr bool _Den_is_one = _CF::den == 1;

	mov	BYTE PTR __Den_is_one$[ebp], 1

; 372  :         return _Num_is_one && _Den_is_one

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN7@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, eax
	call	__ltod3
	movsd	QWORD PTR $T11[ebp], xmm0
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T12[ebp]
	call	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
	mov	DWORD PTR tv131[ebp], eax
	jmp	$LN8@duration_c
$LN7@duration_c:
	xor	edx, edx
	je	SHORT $LN5@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, eax
	call	__ltod3
	mulsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR $T7[ebp], xmm0
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
	mov	DWORD PTR tv128[ebp], eax
	jmp	$LN6@duration_c
$LN5@duration_c:
	xor	ecx, ecx
	je	SHORT $LN3@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, eax
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR $T3[ebp], xmm0
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN4@duration_c
$LN3@duration_c:
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, eax
	call	__ltod3
	mulsd	xmm0, QWORD PTR __real@3ff0000000000000
	divsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR $T1[ebp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
	mov	DWORD PTR tv93[ebp], eax
$LN4@duration_c:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR $T6[ebp+4], ecx
	lea	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR tv128[ebp], edx
$LN6@duration_c:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR $T10[ebp+4], eax
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR tv131[ebp], ecx
$LN8@duration_c:
	mov	edx, DWORD PTR tv131[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z
_TEXT	SEGMENT
tv154 = -448						; size = 8
tv89 = -440						; size = 4
tv148 = -436						; size = 8
tv92 = -428						; size = 4
tv141 = -424						; size = 8
tv95 = -416						; size = 4
$T1 = -408						; size = 8
$T2 = -392						; size = 8
$T3 = -376						; size = 8
$T4 = -360						; size = 8
$T5 = -344						; size = 4
$T6 = -332						; size = 8
$T7 = -316						; size = 8
$T8 = -300						; size = 8
$T9 = -284						; size = 4
$T10 = -272						; size = 8
$T11 = -256						; size = 8
$T12 = -240						; size = 8
$T13 = -224						; size = 4
__Den_is_one$ = -17					; size = 1
__Num_is_one$ = -5					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>, COMDAT

; 364  :         const duration<_Rep, _Period>& _Dur) { // convert duration to another duration; truncate

	push	ebp
	mov	ebp, esp
	sub	esp, 448				; 000001c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-448]
	mov	ecx, 112				; 00000070H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;

	mov	BYTE PTR __Num_is_one$[ebp], 0

; 371  :         constexpr bool _Den_is_one = _CF::den == 1;

	mov	BYTE PTR __Den_is_one$[ebp], 1

; 372  :         return _Num_is_one && _Den_is_one

	xor	eax, eax
	je	SHORT $LN7@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
	fstp	QWORD PTR $T11[ebp]
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T12[ebp]
	call	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
	mov	DWORD PTR tv95[ebp], eax
	jmp	$LN8@duration_c
$LN7@duration_c:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
	fstp	QWORD PTR tv141[ebp]
	movsd	xmm0, QWORD PTR tv141[ebp]
	mulsd	xmm0, QWORD PTR __real@41cdcd6500000000
	movsd	QWORD PTR $T7[ebp], xmm0
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
	mov	DWORD PTR tv92[ebp], eax
	jmp	$LN6@duration_c
$LN5@duration_c:
	xor	ecx, ecx
	je	SHORT $LN3@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
	fstp	QWORD PTR tv148[ebp]
	movsd	xmm0, QWORD PTR tv148[ebp]
	divsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR $T3[ebp], xmm0
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN4@duration_c
$LN3@duration_c:
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1> >::count
	fstp	QWORD PTR tv154[ebp]
	movsd	xmm0, QWORD PTR tv154[ebp]
	mulsd	xmm0, QWORD PTR __real@41cdcd6500000000
	divsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR $T1[ebp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0NX@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABN@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,void>
	mov	DWORD PTR tv89[ebp], eax
$LN4@duration_c:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR $T6[ebp+4], ecx
	lea	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR tv92[ebp], edx
$LN6@duration_c:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR $T10[ebp+4], eax
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR tv95[ebp], ecx
$LN8@duration_c:
	mov	edx, DWORD PTR tv95[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 448				; 000001c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$forward@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@@Z PROC ; std::forward<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > * &>, COMDAT

; 1301 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1302 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1303 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@@Z ENDP ; std::forward<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@?$_Tuple_val@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Arg$ = 8						; size = 4
??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@?$_Tuple_val@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z PROC ; std::_Tuple_val<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::_Tuple_val<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 161  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@?$_Tuple_val@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ENDP ; std::_Tuple_val<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::_Tuple_val<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$forward@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@@Z PROC ; std::forward<std::tuple<<lambda_463439238b6f21205974601aef348251> > * &>, COMDAT

; 1301 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1302 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1303 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@@Z ENDP ; std::forward<std::tuple<<lambda_463439238b6f21205974601aef348251> > * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$?0V<lambda_463439238b6f21205974601aef348251>@@@?$_Tuple_val@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Arg$ = 8						; size = 4
??$?0V<lambda_463439238b6f21205974601aef348251>@@@?$_Tuple_val@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z PROC ; std::_Tuple_val<<lambda_463439238b6f21205974601aef348251> >::_Tuple_val<<lambda_463439238b6f21205974601aef348251> ><<lambda_463439238b6f21205974601aef348251> >, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ; std::forward<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 161  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V<lambda_463439238b6f21205974601aef348251>@@@?$_Tuple_val@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ENDP ; std::_Tuple_val<<lambda_463439238b6f21205974601aef348251> >::_Tuple_val<<lambda_463439238b6f21205974601aef348251> ><<lambda_463439238b6f21205974601aef348251> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 223  :     constexpr tuple(_Tag) noexcept { // construct from one arg per element

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4

; 224  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z
_TEXT	SEGMENT
tv87 = -424						; size = 4
tv90 = -420						; size = 4
tv93 = -416						; size = 4
$T1 = -408						; size = 8
$T2 = -392						; size = 8
$T3 = -376						; size = 8
$T4 = -360						; size = 8
$T5 = -344						; size = 4
$T6 = -332						; size = 8
$T7 = -316						; size = 8
$T8 = -300						; size = 8
$T9 = -284						; size = 4
$T10 = -272						; size = 8
$T11 = -256						; size = 8
$T12 = -240						; size = 8
$T13 = -224						; size = 4
__Den_is_one$ = -17					; size = 1
__Num_is_one$ = -5					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>, COMDAT

; 364  :         const duration<_Rep, _Period>& _Dur) { // convert duration to another duration; truncate

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-424]
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;

	mov	BYTE PTR __Num_is_one$[ebp], 0

; 371  :         constexpr bool _Den_is_one = _CF::den == 1;

	mov	BYTE PTR __Den_is_one$[ebp], 1

; 372  :         return _Num_is_one && _Den_is_one

	xor	eax, eax
	je	SHORT $LN7@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR $T11[ebp+4], edx
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T12[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv93[ebp], eax
	jmp	$LN8@duration_c
$LN7@duration_c:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR $T7[ebp+4], edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv90[ebp], eax
	jmp	$LN6@duration_c
$LN5@duration_c:
	xor	ecx, ecx
	je	SHORT $LN3@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN4@duration_c
$LN3@duration_c:
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv87[ebp], eax
$LN4@duration_c:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR $T6[ebp+4], ecx
	lea	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR tv90[ebp], edx
$LN6@duration_c:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR $T10[ebp+4], eax
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR tv93[ebp], ecx
$LN8@duration_c:
	mov	edx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 77   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Dur$ = 8						; size = 4
??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>, COMDAT
; _this$ = ecx

; 84   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) { // construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Dur$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
	mov	edx, DWORD PTR _this$[ebp]
	fstp	QWORD PTR [edx]

; 85   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Dur$ = 8						; size = 4
??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>, COMDAT
; _this$ = ecx

; 84   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) { // construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Dur$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@NU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@NU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1,1000000000> >,double,std::ratio<1,1>,void>
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
	mov	edx, DWORD PTR _this$[ebp]
	fstp	QWORD PTR [edx]

; 85   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
tv87 = -424						; size = 4
tv90 = -420						; size = 4
tv93 = -416						; size = 4
$T1 = -408						; size = 8
$T2 = -392						; size = 8
$T3 = -376						; size = 8
$T4 = -360						; size = 8
$T5 = -344						; size = 4
$T6 = -332						; size = 8
$T7 = -316						; size = 8
$T8 = -300						; size = 8
$T9 = -284						; size = 4
$T10 = -272						; size = 8
$T11 = -256						; size = 8
$T12 = -240						; size = 8
$T13 = -224						; size = 4
__Den_is_one$ = -17					; size = 1
__Num_is_one$ = -5					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>, COMDAT

; 364  :         const duration<_Rep, _Period>& _Dur) { // convert duration to another duration; truncate

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-424]
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;

	mov	BYTE PTR __Num_is_one$[ebp], 0

; 371  :         constexpr bool _Den_is_one = _CF::den == 1;

	mov	BYTE PTR __Den_is_one$[ebp], 1

; 372  :         return _Num_is_one && _Den_is_one

	xor	eax, eax
	je	SHORT $LN7@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR $T11[ebp+4], edx
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T12[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv93[ebp], eax
	jmp	$LN8@duration_c
$LN7@duration_c:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
	push	0
	push	100					; 00000064H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR $T7[ebp+4], edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv90[ebp], eax
	jmp	$LN6@duration_c
$LN5@duration_c:
	xor	ecx, ecx
	je	SHORT $LN3@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN4@duration_c
$LN3@duration_c:
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
	push	0
	push	100					; 00000064H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv87[ebp], eax
$LN4@duration_c:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR $T6[ebp+4], ecx
	lea	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR tv90[ebp], edx
$LN6@duration_c:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR $T10[ebp+4], eax
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR tv93[ebp], ecx
$LN8@duration_c:
	mov	edx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z
_TEXT	SEGMENT
tv71 = -244						; size = 4
tv95 = -240						; size = 8
tv92 = -232						; size = 8
$T1 = -220						; size = 8
$T2 = -204						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z PROC ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 338  :         const duration<_Rep2, _Period2>& _Right) { // test if duration < duration

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 339  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 340  :         return _CT(_Left).count() < _CT(_Right).count();

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR $T2[ebp+4], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	DWORD PTR $T1[ebp+4], edx
	lea	ecx, DWORD PTR $T2[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	esi, eax
	mov	edi, edx
	lea	ecx, DWORD PTR $T1[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR tv92[ebp], esi
	mov	DWORD PTR tv92[ebp+4], edi
	mov	DWORD PTR tv95[ebp], eax
	mov	DWORD PTR tv95[ebp+4], edx
	mov	eax, DWORD PTR tv92[ebp+4]
	cmp	eax, DWORD PTR tv95[ebp+4]
	jg	SHORT $LN3@operator
	jl	SHORT $LN5@operator
	mov	ecx, DWORD PTR tv92[ebp]
	cmp	ecx, DWORD PTR tv95[ebp]
	jae	SHORT $LN3@operator
$LN5@operator:
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv71[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv71[ebp]

; 341  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ENDP ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
tv87 = -424						; size = 4
tv90 = -420						; size = 4
tv93 = -416						; size = 4
$T1 = -408						; size = 8
$T2 = -392						; size = 8
$T3 = -376						; size = 8
$T4 = -360						; size = 8
$T5 = -344						; size = 4
$T6 = -332						; size = 8
$T7 = -316						; size = 8
$T8 = -300						; size = 8
$T9 = -284						; size = 4
$T10 = -272						; size = 8
$T11 = -256						; size = 8
$T12 = -240						; size = 8
$T13 = -224						; size = 4
__Den_is_one$ = -17					; size = 1
__Num_is_one$ = -5					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>, COMDAT

; 364  :         const duration<_Rep, _Period>& _Dur) { // convert duration to another duration; truncate

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-424]
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;

	mov	BYTE PTR __Num_is_one$[ebp], 0

; 371  :         constexpr bool _Den_is_one = _CF::den == 1;

	mov	BYTE PTR __Den_is_one$[ebp], 1

; 372  :         return _Num_is_one && _Den_is_one

	xor	eax, eax
	je	SHORT $LN7@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR $T11[ebp+4], edx
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T12[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv93[ebp], eax
	jmp	$LN8@duration_c
$LN7@duration_c:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	push	0
	push	1000000					; 000f4240H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR $T7[ebp+4], edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv90[ebp], eax
	jmp	$LN6@duration_c
$LN5@duration_c:
	xor	ecx, ecx
	je	SHORT $LN3@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN4@duration_c
$LN3@duration_c:
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	push	0
	push	1000000					; 000f4240H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv87[ebp], eax
$LN4@duration_c:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR $T6[ebp+4], ecx
	lea	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR tv90[ebp], edx
$LN6@duration_c:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR $T10[ebp+4], eax
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR tv93[ebp], ecx
$LN8@duration_c:
	mov	edx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xmemory0
;	COMDAT ??$?0AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1>::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1><std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > * &>, COMDAT
; _this$ = ecx

; 1511 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A7902F0C_xmemory0
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	push	eax
	call	??$forward@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@@Z ; std::forward<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > * &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 1512 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1>::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1><std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@U_Exact_args_t@1@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@U_Exact_args_t@1@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z PROC ; std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><std::_Exact_args_t,<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>, COMDAT
; _this$ = ecx

; 250  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...),

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element

	mov	eax, DWORD PTR __This_arg$[ebp]
	push	eax
	call	??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@?$_Tuple_val@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ; std::_Tuple_val<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::_Tuple_val<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >

; 252  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0U_Exact_args_t@std@@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@U_Exact_args_t@1@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ENDP ; std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><std::_Exact_args_t,<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xmemory0
;	COMDAT ??$?0AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1>::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1><std::tuple<<lambda_463439238b6f21205974601aef348251> > * &>, COMDAT
; _this$ = ecx

; 1511 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A7902F0C_xmemory0
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	push	eax
	call	??$forward@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@YAAAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@@Z ; std::forward<std::tuple<<lambda_463439238b6f21205974601aef348251> > * &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 1512 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1>::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1><std::tuple<<lambda_463439238b6f21205974601aef348251> > * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@U_Exact_args_t@1@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@U_Exact_args_t@1@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z PROC ; std::tuple<<lambda_463439238b6f21205974601aef348251> >::tuple<<lambda_463439238b6f21205974601aef348251> ><std::_Exact_args_t,<lambda_463439238b6f21205974601aef348251>,0>, COMDAT
; _this$ = ecx

; 250  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...),

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element

	mov	eax, DWORD PTR __This_arg$[ebp]
	push	eax
	call	??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ; std::forward<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V<lambda_463439238b6f21205974601aef348251>@@@?$_Tuple_val@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ; std::_Tuple_val<<lambda_463439238b6f21205974601aef348251> >::_Tuple_val<<lambda_463439238b6f21205974601aef348251> ><<lambda_463439238b6f21205974601aef348251> >

; 252  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0U_Exact_args_t@std@@V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@U_Exact_args_t@1@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ENDP ; std::tuple<<lambda_463439238b6f21205974601aef348251> >::tuple<<lambda_463439238b6f21205974601aef348251> ><std::_Exact_args_t,<lambda_463439238b6f21205974601aef348251>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Dur$ = 8						; size = 4
??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>, COMDAT
; _this$ = ecx

; 84   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) { // construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Dur$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1>,void>
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 85   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
tv87 = -424						; size = 4
tv90 = -420						; size = 4
tv93 = -416						; size = 4
$T1 = -408						; size = 8
$T2 = -392						; size = 8
$T3 = -376						; size = 8
$T4 = -360						; size = 8
$T5 = -344						; size = 4
$T6 = -332						; size = 8
$T7 = -316						; size = 8
$T8 = -300						; size = 8
$T9 = -284						; size = 4
$T10 = -272						; size = 8
$T11 = -256						; size = 8
$T12 = -240						; size = 8
$T13 = -224						; size = 4
__Den_is_one$ = -17					; size = 1
__Num_is_one$ = -5					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>, COMDAT

; 364  :         const duration<_Rep, _Period>& _Dur) { // convert duration to another duration; truncate

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-424]
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;

	mov	BYTE PTR __Num_is_one$[ebp], 1

; 371  :         constexpr bool _Den_is_one = _CF::den == 1;

	mov	BYTE PTR __Den_is_one$[ebp], 0

; 372  :         return _Num_is_one && _Den_is_one

	xor	eax, eax
	je	SHORT $LN7@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR $T11[ebp+4], edx
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T12[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
	mov	DWORD PTR tv93[ebp], eax
	jmp	$LN8@duration_c
$LN7@duration_c:
	xor	edx, edx
	je	SHORT $LN5@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR $T7[ebp+4], edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
	mov	DWORD PTR tv90[ebp], eax
	jmp	$LN6@duration_c
$LN5@duration_c:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN3@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN4@duration_c
$LN3@duration_c:
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64,void>
	mov	DWORD PTR tv87[ebp], eax
$LN4@duration_c:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR $T6[ebp+4], ecx
	lea	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR tv90[ebp], edx
$LN6@duration_c:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR $T10[ebp+4], eax
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR tv93[ebp], ecx
$LN8@duration_c:
	mov	edx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z
_TEXT	SEGMENT
tv85 = -424						; size = 4
tv88 = -420						; size = 4
tv91 = -416						; size = 4
$T1 = -408						; size = 8
$T2 = -392						; size = 8
$T3 = -376						; size = 8
$T4 = -360						; size = 8
$T5 = -344						; size = 4
$T6 = -332						; size = 8
$T7 = -316						; size = 8
$T8 = -300						; size = 8
$T9 = -284						; size = 4
$T10 = -272						; size = 8
$T11 = -256						; size = 8
$T12 = -240						; size = 8
$T13 = -224						; size = 4
__Den_is_one$ = -17					; size = 1
__Num_is_one$ = -5					; size = 1
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>, COMDAT

; 364  :         const duration<_Rep, _Period>& _Dur) { // convert duration to another duration; truncate

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-424]
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;

	mov	BYTE PTR __Num_is_one$[ebp], 1

; 371  :         constexpr bool _Den_is_one = _CF::den == 1;

	mov	BYTE PTR __Den_is_one$[ebp], 1

; 372  :         return _Num_is_one && _Den_is_one

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN7@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR $T11[ebp+4], edx
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T12[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv91[ebp], eax
	jmp	$LN8@duration_c
$LN7@duration_c:
	xor	edx, edx
	je	SHORT $LN5@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR $T7[ebp+4], edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv88[ebp], eax
	jmp	$LN6@duration_c
$LN5@duration_c:
	xor	ecx, ecx
	je	SHORT $LN3@duration_c
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN4@duration_c
$LN3@duration_c:
	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	DWORD PTR tv85[ebp], eax
$LN4@duration_c:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR $T6[ebp+4], ecx
	lea	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR tv88[ebp], edx
$LN6@duration_c:
	mov	eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR $T10[ebp+4], eax
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN8@duration_c:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
tv75 = -252						; size = 4
tv90 = -248						; size = 8
tv93 = -240						; size = 8
tv84 = -232						; size = 8
$T1 = -220						; size = 8
$T2 = -204						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >, COMDAT

; 338  :         const duration<_Rep2, _Period2>& _Right) { // test if duration < duration

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 339  :         using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 340  :         return _CT(_Left).count() < _CT(_Right).count();

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0NU?$ratio@$00$00@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@NU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><double,std::ratio<1,1>,void>
	mov	ecx, eax
	call	?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
	fstp	QWORD PTR tv84[ebp]
	movsd	xmm0, QWORD PTR tv84[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T1[ebp]
	movsd	QWORD PTR tv93[ebp], xmm0
	call	??$?0_JU?$ratio@$00$0DLJKMKAA@@std@@X@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::duration<double,std::ratio<1,1000000000> >::duration<double,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000000000>,void>
	mov	ecx, eax
	call	?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
	fstp	QWORD PTR tv90[ebp]
	movsd	xmm0, QWORD PTR tv90[ebp]
	movsd	xmm1, QWORD PTR tv93[ebp]
	comisd	xmm0, xmm1
	jbe	SHORT $LN3@operator
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv75[ebp]

; 341  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Dur$ = 8						; size = 4
??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>, COMDAT
; _this$ = ecx

; 84   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) { // construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Dur$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000>,void>
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 85   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
$T1 = -236						; size = 8
$T2 = -220						; size = 8
$T3 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 247  :         const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) { // subtract two durations

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 248  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR $T2[ebp+4], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	DWORD PTR $T1[ebp+4], edx
	lea	ecx, DWORD PTR $T2[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	esi, eax
	mov	edi, edx
	lea	ecx, DWORD PTR $T1[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	sub	esi, eax
	sbb	edi, edx
	mov	DWORD PTR $T3[ebp], esi
	mov	DWORD PTR $T3[ebp+4], edi
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 250  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
$T1 = -220						; size = 8
$T2 = -204						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 493  :         const time_point<_Clock, _Duration2>& _Right) { // test for time_point < time_point

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 494  :         return _Left.time_since_epoch() < _Right.time_since_epoch();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
	push	eax
	call	??$?M_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
	add	esp, 8

; 495  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Dur$ = 8						; size = 4
??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>, COMDAT
; _this$ = ecx

; 84   :             : _MyRep(chrono::duration_cast<duration>(_Dur).count()) { // construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Dur$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000>,void>
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 85   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$invoke@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V@std@@YAX$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$invoke@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V@std@@YAX$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z PROC ; std::invoke<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >, COMDAT

; 1452 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	push	eax
	call	??$_Call@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V@_Invoker_functor@std@@SAX$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ; std::_Invoker_functor::_Call<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$invoke@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V@std@@YAX$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ENDP ; std::invoke<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$_Call@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V@_Invoker_functor@std@@SAX$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Call@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V@_Invoker_functor@std@@SAX$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z PROC ; std::_Invoker_functor::_Call<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >, COMDAT

; 1452 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	mov	ecx, eax
	call	??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ ; <lambda_7ec1dc920a35512b9dcd3a4255af04b6>::operator()
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Call@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V@_Invoker_functor@std@@SAX$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ENDP ; std::_Invoker_functor::_Call<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$move@AAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$move@AAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z PROC ; std::move<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> &>, COMDAT

; 1313 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$move@AAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1314 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1315 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$move@AAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$move@AAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$move@AAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ENDP ; std::move<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$get@$0A@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YAAAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Tuple$ = 8						; size = 4
??$get@$0A@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YAAAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@@Z PROC ; std::get<0,<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >, COMDAT

; 644  :     tuple<_Types...>& _Tuple) noexcept { // get reference to _Index element of tuple

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$get@$0A@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YAAAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[ebp]

; 647  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$get@$0A@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YAAAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$get@$0A@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YAAAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$get@$0A@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YAAAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@@Z ENDP ; std::get<0,<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z PROC ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > ><std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,0>, COMDAT
; _this$ = ecx

; 1804 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4
	lea	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1>::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1><std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > * &>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z ENDP ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > ><std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z PROC ; std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>, COMDAT
; _this$ = ecx

; 319  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	mov	ecx, DWORD PTR __This_arg$[ebp]
	push	ecx
	call	??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	push	eax
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U_Exact_args_t@std@@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@U_Exact_args_t@1@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ; std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><std::_Exact_args_t,<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ENDP ; std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$invoke@V<lambda_463439238b6f21205974601aef348251>@@$$V@std@@YAX$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$invoke@V<lambda_463439238b6f21205974601aef348251>@@$$V@std@@YAX$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z PROC ; std::invoke<<lambda_463439238b6f21205974601aef348251> >, COMDAT

; 1452 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ; std::forward<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	push	eax
	call	??$_Call@V<lambda_463439238b6f21205974601aef348251>@@$$V@_Invoker_functor@std@@SAX$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ; std::_Invoker_functor::_Call<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$invoke@V<lambda_463439238b6f21205974601aef348251>@@$$V@std@@YAX$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ENDP ; std::invoke<<lambda_463439238b6f21205974601aef348251> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$_Call@V<lambda_463439238b6f21205974601aef348251>@@$$V@_Invoker_functor@std@@SAX$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Call@V<lambda_463439238b6f21205974601aef348251>@@$$V@_Invoker_functor@std@@SAX$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z PROC ; std::_Invoker_functor::_Call<<lambda_463439238b6f21205974601aef348251> >, COMDAT

; 1452 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ; std::forward<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	mov	ecx, eax
	call	??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ ; <lambda_463439238b6f21205974601aef348251>::operator()
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Call@V<lambda_463439238b6f21205974601aef348251>@@$$V@_Invoker_functor@std@@SAX$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ENDP ; std::_Invoker_functor::_Call<<lambda_463439238b6f21205974601aef348251> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$move@AAV<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$move@AAV<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z PROC ; std::move<<lambda_463439238b6f21205974601aef348251> &>, COMDAT

; 1313 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$move@AAV<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1314 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1315 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$move@AAV<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$move@AAV<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$move@AAV<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ENDP ; std::move<<lambda_463439238b6f21205974601aef348251> &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$get@$0A@V<lambda_463439238b6f21205974601aef348251>@@@std@@YAAAV<lambda_463439238b6f21205974601aef348251>@@AAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Tuple$ = 8						; size = 4
??$get@$0A@V<lambda_463439238b6f21205974601aef348251>@@@std@@YAAAV<lambda_463439238b6f21205974601aef348251>@@AAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@@Z PROC ; std::get<0,<lambda_463439238b6f21205974601aef348251> >, COMDAT

; 644  :     tuple<_Types...>& _Tuple) noexcept { // get reference to _Index element of tuple

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$get@$0A@V<lambda_463439238b6f21205974601aef348251>@@@std@@YAAAV<lambda_463439238b6f21205974601aef348251>@@AAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[ebp]

; 647  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$get@$0A@V<lambda_463439238b6f21205974601aef348251>@@@std@@YAAAV<lambda_463439238b6f21205974601aef348251>@@AAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$get@$0A@V<lambda_463439238b6f21205974601aef348251>@@@std@@YAAAV<lambda_463439238b6f21205974601aef348251>@@AAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$get@$0A@V<lambda_463439238b6f21205974601aef348251>@@@std@@YAAAV<lambda_463439238b6f21205974601aef348251>@@AAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@@Z ENDP ; std::get<0,<lambda_463439238b6f21205974601aef348251> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z PROC ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > ><std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,0>, COMDAT
; _this$ = ecx

; 1804 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4
	lea	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1>::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1><std::tuple<<lambda_463439238b6f21205974601aef348251> > * &>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z ENDP ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > ><std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\tuple
;	COMDAT ??$?0V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
??$?0V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z PROC ; std::tuple<<lambda_463439238b6f21205974601aef348251> >::tuple<<lambda_463439238b6f21205974601aef348251> ><<lambda_463439238b6f21205974601aef348251>,0>, COMDAT
; _this$ = ecx

; 319  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E2A63297_tuple
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	BYTE PTR $T2[ebp], al
	mov	ecx, DWORD PTR __This_arg$[ebp]
	push	ecx
	call	??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ; std::forward<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	push	eax
	movzx	edx, BYTE PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U_Exact_args_t@std@@V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@U_Exact_args_t@1@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ; std::tuple<<lambda_463439238b6f21205974601aef348251> >::tuple<<lambda_463439238b6f21205974601aef348251> ><std::_Exact_args_t,<lambda_463439238b6f21205974601aef348251>,0>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ENDP ; std::tuple<<lambda_463439238b6f21205974601aef348251> >::tuple<<lambda_463439238b6f21205974601aef348251> ><<lambda_463439238b6f21205974601aef348251>,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z
_TEXT	SEGMENT
$T1 = -332						; size = 8
$T2 = -316						; size = 8
$T3 = -300						; size = 8
$T4 = -284						; size = 8
__Whole_seconds$ = -76					; size = 8
__Clamped$ = -57					; size = 1
__T0$ = -48						; size = 8
__Ten_days_d$ = -32					; size = 8
__Ten_days$ = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
__Xt$ = 8						; size = 4
__Rel_time$ = 12					; size = 4
??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z PROC ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >, COMDAT

; 589  : _NODISCARD inline bool _To_xtime_10_day_clamped(_CSTD xtime& _Xt, const chrono::duration<_Rep, _Period>& _Rel_time) {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-336]
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 590  :     // Convert duration to xtime, maximum 10 days from now, returns whether clamping occurred.
; 591  :     // If clamped, timeouts will be transformed into spurious non-timeout wakes, due to ABI restrictions where
; 592  :     // the other side of the DLL boundary overflows int32_t milliseconds.
; 593  :     // Every function calling this one is TRANSITION, ABI
; 594  :     constexpr chrono::nanoseconds _Ten_days{chrono::hours{24} * 10};

	mov	DWORD PTR __Ten_days$[ebp], -1391067136	; ad160000H
	mov	DWORD PTR __Ten_days$[ebp+4], 201165	; 000311cdH

; 595  :     constexpr chrono::duration<double> _Ten_days_d{_Ten_days};

	movsd	xmm0, QWORD PTR __real@412a5e0000000000
	movsd	QWORD PTR __Ten_days_d$[ebp], xmm0

; 596  :     chrono::nanoseconds _T0 = chrono::system_clock::now().time_since_epoch();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
	add	esp, 4
	mov	ecx, eax
	call	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
	push	eax
	lea	ecx, DWORD PTR __T0$[ebp]
	call	??$?0_JU?$ratio@$00$0JIJGIA@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000>,void>

; 597  :     const bool _Clamped     = _Ten_days_d < _Rel_time;

	mov	eax, DWORD PTR __Rel_time$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ten_days_d$[ebp]
	push	ecx
	call	??$?MNU?$ratio@$00$00@std@@_JU?$ratio@$00$0DLJKMKAA@@1@@chrono@std@@YA_NABV?$duration@NU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::operator<<double,std::ratio<1,1>,__int64,std::ratio<1,1000000000> >
	add	esp, 8
	mov	BYTE PTR __Clamped$[ebp], al

; 598  :     if (_Clamped) {

	movzx	eax, BYTE PTR __Clamped$[ebp]
	test	eax, eax
	je	SHORT $LN2@To_xtime_1

; 599  :         _T0 += _Ten_days;

	lea	eax, DWORD PTR __Ten_days$[ebp]
	push	eax
	lea	ecx, DWORD PTR __T0$[ebp]
	call	??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=

; 600  :     } else {

	jmp	SHORT $LN3@To_xtime_1
$LN2@To_xtime_1:

; 601  :         _T0 += chrono::duration_cast<chrono::nanoseconds>(_Rel_time);

	mov	eax, DWORD PTR __Rel_time$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000000000>,void>
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR __T0$[ebp]
	call	??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
$LN3@To_xtime_1:

; 602  :     }
; 603  : 
; 604  :     const auto _Whole_seconds = chrono::duration_cast<chrono::seconds>(_T0);

	lea	eax, DWORD PTR __T0$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Whole_seconds$[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000>,void>
	add	esp, 8

; 605  :     _Xt.sec                   = _Whole_seconds.count();

	lea	ecx, DWORD PTR __Whole_seconds$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	mov	ecx, DWORD PTR __Xt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 606  :     _T0 -= _Whole_seconds;

	lea	eax, DWORD PTR __Whole_seconds$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??$?0_JU?$ratio@$00$00@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1>,void>
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR __T0$[ebp]
	call	??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=

; 607  :     _Xt.nsec = static_cast<long>(_T0.count());

	lea	ecx, DWORD PTR __T0$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, DWORD PTR __Xt$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 608  :     return _Clamped;

	mov	al, BYTE PTR __Clamped$[ebp]

; 609  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@To_xtime_1
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 336				; 00000150H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@To_xtime_1:
	DD	4
	DD	$LN9@To_xtime_1
$LN9@To_xtime_1:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN5@To_xtime_1
	DD	-32					; ffffffe0H
	DD	8
	DD	$LN6@To_xtime_1
	DD	-48					; ffffffd0H
	DD	8
	DD	$LN7@To_xtime_1
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN8@To_xtime_1
$LN8@To_xtime_1:
	DB	95					; 0000005fH
	DB	87					; 00000057H
	DB	104					; 00000068H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN7@To_xtime_1:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	48					; 00000030H
	DB	0
$LN6@To_xtime_1:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	100					; 00000064H
	DB	0
$LN5@To_xtime_1:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	0
??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ENDP ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
$T1 = -220						; size = 8
$T2 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 474  :         const time_point<_Clock, _Duration2>& _Right) { // add time_point to time_point

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 475  :         return _Left.time_since_epoch() - _Right.time_since_epoch();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
	push	eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 476  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 499  :         const time_point<_Clock, _Duration2>& _Right) { // test for time_point <= time_point

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 500  :         return !(_Right < _Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	call	??$?MUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 501  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 8
$T2 = -220						; size = 8
$T3 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >, COMDAT

; 240  :         const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) { // add two durations

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 241  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 242  :         return _CD(_CD(_Left).count() + _CD(_Right).count());

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR $T2[ebp+4], edx
	lea	ecx, DWORD PTR $T2[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	esi, eax
	mov	edi, edx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??$?0_JU?$ratio@$00$0DOI@@std@@X@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000>,void>
	mov	ecx, eax
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	add	esi, eax
	adc	edi, edx
	mov	DWORD PTR $T3[ebp], esi
	mov	DWORD PTR $T3[ebp+4], edi
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 243  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\utility
;	COMDAT ??$exchange@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@PAV12@@std@@YAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@$$QAPAV10@@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@PAV12@@std@@YAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@$$QAPAV10@@Z PROC ; std::exchange<std::tuple<<lambda_463439238b6f21205974601aef348251> > *,std::tuple<<lambda_463439238b6f21205974601aef348251> > *>, COMDAT

; 525  : inline _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9D9C0E17_utility
	call	@__CheckForDebuggerJustMyCode@4

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 528  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 529  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@PAV12@@std@@YAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@$$QAPAV10@@Z ENDP ; std::exchange<std::tuple<<lambda_463439238b6f21205974601aef348251> > *,std::tuple<<lambda_463439238b6f21205974601aef348251> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\utility
;	COMDAT ??$exchange@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@PAV12@@std@@YAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@$$QAPAV10@@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@PAV12@@std@@YAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@$$QAPAV10@@Z PROC ; std::exchange<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *>, COMDAT

; 525  : inline _Ty exchange(_Ty& _Val, _Other&& _New_val) { // assign _New_val to _Val, return previous _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9D9C0E17_utility
	call	@__CheckForDebuggerJustMyCode@4

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 528  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 529  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@PAV12@@std@@YAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@$$QAPAV10@@Z ENDP ; std::exchange<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z
_TEXT	SEGMENT
$T2 = -240						; size = 4
__Tup$ = -36						; size = 4
__FnVals$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__RawVals$ = 8						; size = 4
??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z PROC ; std::thread::_Invoke<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,0>, COMDAT

; 35   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept { // enforces termination

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4

; 36   :         // adapt invoke of user's callable object to _beginthreadex's thread procedure
; 37   :         const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals));

	push	4
	lea	ecx, DWORD PTR __FnVals$[ebp]
	call	?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR __RawVals$[ebp]
	push	eax
	lea	ecx, DWORD PTR __FnVals$[ebp]
	call	??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > ><std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,0>

; 38   :         _Tuple& _Tup = *_FnVals;

	lea	ecx, DWORD PTR __FnVals$[ebp]
	call	??D?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEAAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@XZ ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::operator*
	mov	DWORD PTR __Tup$[ebp], eax

; 39   :         _STD invoke(_STD move(_STD get<_Indices>(_Tup))...);

	mov	eax, DWORD PTR __Tup$[ebp]
	push	eax
	call	??$get@$0A@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YAAAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@@Z ; std::get<0,<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	push	eax
	call	??$move@AAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ; std::move<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> &>
	add	esp, 4
	push	eax
	call	??$invoke@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V@std@@YAX$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ; std::invoke<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4

; 40   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

	call	__Cnd_do_broadcast_at_thread_exit

; 41   :         return 0;

	mov	DWORD PTR $T2[ebp], 0
	lea	ecx, DWORD PTR __FnVals$[ebp]
	call	??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::~unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >
	mov	eax, DWORD PTR $T2[ebp]

; 42   :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Invoke
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@Invoke:
	DD	1
	DD	$LN5@Invoke
$LN5@Invoke:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Invoke
$LN3@Invoke:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	110					; 0000006eH
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z ENDP ; std::thread::_Invoke<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,0>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEXI@Z PROC ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEXI@Z ENDP ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1520 :     _Ty1& _Get_first() noexcept { // return reference to first

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A7902F0C_xmemory0
	call	@__CheckForDebuggerJustMyCode@4

; 1521 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1522 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ?release@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?release@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ PROC ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::release, COMDAT
; _this$ = ecx

; 1887 :     pointer release() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?release@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1888 :         return _STD exchange(_Mypair._Myval2, pointer());

	mov	DWORD PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@PAV12@@std@@YAPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@0@AAPAV10@$$QAPAV10@@Z ; std::exchange<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *>
	add	esp, 8

; 1889 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?release@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?release@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?release@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ ENDP ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::release
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ?get@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?get@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ PROC ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::get, COMDAT
; _this$ = ecx

; 1879 :     _NODISCARD pointer get() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1880 :         return _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1881 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?get@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?get@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?get@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ ENDP ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::get
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??D?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEAAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEAAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@XZ PROC ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::operator*, COMDAT
; _this$ = ecx

; 1871 :     _NODISCARD add_lvalue_reference_t<_Ty> operator*() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1872 :         return *_Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1873 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEAAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@XZ ENDP ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::~unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >, COMDAT
; _this$ = ecx

; 1857 :     ~unique_ptr() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1858 :         if (_Mypair._Myval2 != pointer()) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@unique_ptr

; 1859 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > *,1>::_Get_first
	mov	ecx, eax
	call	??R?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z ; std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >::operator()
$LN3@unique_ptr:

; 1860 :         }
; 1861 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::~unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??R?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z
_TEXT	SEGMENT
tv67 = -232						; size = 4
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??R?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z PROC ; std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >::operator(), COMDAT
; _this$ = ecx

; 1746 :     void operator()(_Ty* _Ptr) const noexcept { // delete a pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1747 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1748 :         delete _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	push	8
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	cmp	DWORD PTR $T2[ebp], 0
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 0
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR __Ptr$[ebp], 33059		; 00008123H
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR tv67[ebp], edx
$LN2@operator:

; 1749 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??R?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??R?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??R?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z ENDP ; std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >::operator()
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??$make_unique@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@0@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
_TEXT	SEGMENT
tv77 = -220						; size = 4
$T1 = -212						; size = 4
$T2 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$make_unique@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@0@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z PROC ; std::make_unique<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>, COMDAT

; 2041 : _NODISCARD inline unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 2042 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@make_uniqu
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T2[ebp]
	call	??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$V$0A@@?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ; std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> ><<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN4@make_uniqu
$LN3@make_uniqu:
	mov	DWORD PTR tv77[ebp], 0
$LN4@make_uniqu:
	mov	ecx, DWORD PTR tv77[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@1@@Z ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > ><std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > >,0>
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2043 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$make_unique@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@0@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ENDP ; std::make_unique<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z PROC ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >, COMDAT

; 1301 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1302 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1303 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ENDP ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z
_TEXT	SEGMENT
$T2 = -240						; size = 4
__Tup$ = -36						; size = 4
__FnVals$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__RawVals$ = 8						; size = 4
??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z PROC ; std::thread::_Invoke<std::tuple<<lambda_463439238b6f21205974601aef348251> >,0>, COMDAT

; 35   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept { // enforces termination

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4

; 36   :         // adapt invoke of user's callable object to _beginthreadex's thread procedure
; 37   :         const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals));

	push	4
	lea	ecx, DWORD PTR __FnVals$[ebp]
	call	?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR __RawVals$[ebp]
	push	eax
	lea	ecx, DWORD PTR __FnVals$[ebp]
	call	??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > ><std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,0>

; 38   :         _Tuple& _Tup = *_FnVals;

	lea	ecx, DWORD PTR __FnVals$[ebp]
	call	??D?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEAAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@XZ ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::operator*
	mov	DWORD PTR __Tup$[ebp], eax

; 39   :         _STD invoke(_STD move(_STD get<_Indices>(_Tup))...);

	mov	eax, DWORD PTR __Tup$[ebp]
	push	eax
	call	??$get@$0A@V<lambda_463439238b6f21205974601aef348251>@@@std@@YAAAV<lambda_463439238b6f21205974601aef348251>@@AAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@@Z ; std::get<0,<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	push	eax
	call	??$move@AAV<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ; std::move<<lambda_463439238b6f21205974601aef348251> &>
	add	esp, 4
	push	eax
	call	??$invoke@V<lambda_463439238b6f21205974601aef348251>@@$$V@std@@YAX$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ; std::invoke<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4

; 40   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

	call	__Cnd_do_broadcast_at_thread_exit

; 41   :         return 0;

	mov	DWORD PTR $T2[ebp], 0
	lea	ecx, DWORD PTR __FnVals$[ebp]
	call	??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::~unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >
	mov	eax, DWORD PTR $T2[ebp]

; 42   :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Invoke
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@Invoke:
	DD	1
	DD	$LN5@Invoke
$LN5@Invoke:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Invoke
$LN3@Invoke:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	110					; 0000006eH
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z ENDP ; std::thread::_Invoke<std::tuple<<lambda_463439238b6f21205974601aef348251> >,0>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEXI@Z PROC ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEXI@Z ENDP ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1520 :     _Ty1& _Get_first() noexcept { // return reference to first

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A7902F0C_xmemory0
	call	@__CheckForDebuggerJustMyCode@4

; 1521 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1522 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1>::_Get_first
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ?release@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?release@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ PROC ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::release, COMDAT
; _this$ = ecx

; 1887 :     pointer release() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?release@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1888 :         return _STD exchange(_Mypair._Myval2, pointer());

	mov	DWORD PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@PAV12@@std@@YAPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@0@AAPAV10@$$QAPAV10@@Z ; std::exchange<std::tuple<<lambda_463439238b6f21205974601aef348251> > *,std::tuple<<lambda_463439238b6f21205974601aef348251> > *>
	add	esp, 8

; 1889 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?release@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?release@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?release@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ ENDP ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::release
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ?get@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?get@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ PROC ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::get, COMDAT
; _this$ = ecx

; 1879 :     _NODISCARD pointer get() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1880 :         return _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1881 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?get@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?get@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?get@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ ENDP ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::get
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??D?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEAAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEAAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@XZ PROC ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::operator*, COMDAT
; _this$ = ecx

; 1871 :     _NODISCARD add_lvalue_reference_t<_Ty> operator*() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1872 :         return *_Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1873 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEAAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@XZ ENDP ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::~unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >, COMDAT
; _this$ = ecx

; 1857 :     ~unique_ptr() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1858 :         if (_Mypair._Myval2 != pointer()) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@unique_ptr

; 1859 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,std::tuple<<lambda_463439238b6f21205974601aef348251> > *,1>::_Get_first
	mov	ecx, eax
	call	??R?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z ; std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >::operator()
$LN3@unique_ptr:

; 1860 :         }
; 1861 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::~unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??R?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z
_TEXT	SEGMENT
tv67 = -232						; size = 4
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??R?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z PROC ; std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >::operator(), COMDAT
; _this$ = ecx

; 1746 :     void operator()(_Ty* _Ptr) const noexcept { // delete a pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 1747 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1748 :         delete _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	push	8
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	cmp	DWORD PTR $T2[ebp], 0
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 0
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR __Ptr$[ebp], 33059		; 00008123H
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR tv67[ebp], edx
$LN2@operator:

; 1749 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??R?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??R?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??R?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@QBEXPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z ENDP ; std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >::operator()
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\memory
;	COMDAT ??$make_unique@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@V<lambda_463439238b6f21205974601aef348251>@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@0@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
_TEXT	SEGMENT
tv77 = -220						; size = 4
$T1 = -212						; size = 4
$T2 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$make_unique@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@V<lambda_463439238b6f21205974601aef348251>@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@0@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z PROC ; std::make_unique<std::tuple<<lambda_463439238b6f21205974601aef348251> >,<lambda_463439238b6f21205974601aef348251>,0>, COMDAT

; 2041 : _NODISCARD inline unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T1[ebp], 0
	mov	ecx, OFFSET __A6DF1811_memory
	call	@__CheckForDebuggerJustMyCode@4

; 2042 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@make_uniqu
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ; std::forward<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T2[ebp]
	call	??$?0V<lambda_463439238b6f21205974601aef348251>@@$$V$0A@@?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ; std::tuple<<lambda_463439238b6f21205974601aef348251> >::tuple<<lambda_463439238b6f21205974601aef348251> ><<lambda_463439238b6f21205974601aef348251>,0>
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN4@make_uniqu
$LN3@make_uniqu:
	mov	DWORD PTR tv77[ebp], 0
$LN4@make_uniqu:
	mov	ecx, DWORD PTR tv77[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@PAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@1@@Z ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > ><std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > >,0>
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2043 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$make_unique@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@V<lambda_463439238b6f21205974601aef348251>@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@0@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ENDP ; std::make_unique<std::tuple<<lambda_463439238b6f21205974601aef348251> >,<lambda_463439238b6f21205974601aef348251>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\type_traits
;	COMDAT ??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z PROC ; std::forward<<lambda_463439238b6f21205974601aef348251> >, COMDAT

; 1301 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __45E68E76_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 1302 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1303 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ENDP ; std::forward<<lambda_463439238b6f21205974601aef348251> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z
_TEXT	SEGMENT
$T1 = -248						; size = 8
__Tgt$2 = -40						; size = 16
__Now$3 = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
__Abs_time$ = 8						; size = 4
??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z PROC ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 147  :     inline void sleep_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) { // sleep until time point

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4
$LN4@sleep_unti:

; 148  :         for (;;) {
; 149  :             const auto _Now = _Clock::now();

	lea	eax, DWORD PTR __Now$3[ebp]
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
	add	esp, 4

; 150  :             if (_Abs_time <= _Now) {

	lea	eax, DWORD PTR __Now$3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Abs_time$[ebp]
	push	ecx
	call	??$?NUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA_NABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator<=<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@sleep_unti

; 151  :                 return;

	jmp	SHORT $LN1@sleep_unti
$LN5@sleep_unti:

; 152  :             }
; 153  : 
; 154  :             _CSTD xtime _Tgt;
; 155  :             (void) _To_xtime_10_day_clamped(_Tgt, _Abs_time - _Now);

	lea	eax, DWORD PTR __Now$3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Abs_time$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR __Tgt$2[ebp]
	push	eax
	call	??$_To_xtime_10_day_clamped@_JU?$ratio@$00$0DLJKMKAA@@std@@@std@@YA_NAAUxtime@@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@0@@Z ; std::_To_xtime_10_day_clamped<__int64,std::ratio<1,1000000000> >
	add	esp, 8

; 156  :             _Thrd_sleep(&_Tgt);

	lea	eax, DWORD PTR __Tgt$2[ebp]
	push	eax
	call	__Thrd_sleep
	add	esp, 4

; 157  :         }

	jmp	SHORT $LN4@sleep_unti
$LN1@sleep_unti:

; 158  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@sleep_unti
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@sleep_unti:
	DD	2
	DD	$LN9@sleep_unti
$LN9@sleep_unti:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN7@sleep_unti
	DD	-40					; ffffffd8H
	DD	16					; 00000010H
	DD	$LN8@sleep_unti
$LN8@sleep_unti:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	0
$LN7@sleep_unti:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ENDP ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -220						; size = 8
$T2 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >, COMDAT

; 452  :         const duration<_Rep, _Period>& _Right) { // add duration to time_point

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 453  :         using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
; 454  :         return _RT(_Left.time_since_epoch() + _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$?H_JU?$ratio@$00$0DLJKMKAA@@std@@_JU?$ratio@$00$0DOI@@1@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000> >
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 455  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 119  :         explicit __CLR_OR_THIS_CALL operator bool() const { // test if stream state okay

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 120  :             return _Ok;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 121  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 104  :         __CLR_OR_THIS_CALL ~sentry() noexcept { // destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 105  : #if _HAS_EXCEPTIONS
; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@sentry

; 107  :                 this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@sentry:

; 108  :             }
; 109  : #else // _HAS_EXCEPTIONS
; 110  :             this->_Myostr._Osfx();
; 111  : #endif // _HAS_EXCEPTIONS
; 112  :         }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 89   :             : _Sentry_base(_Ostr) { // construct locking and testing stream

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@sentry
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@sentry
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR __Ostr$[ebp]
	je	SHORT $LN2@sentry

; 91   :                 _Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@sentry:

; 92   :             }
; 93   : 
; 94   :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 95   :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv92 = -224						; size = 4
tv86 = -220						; size = 4
tv72 = -220						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 75   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@Sentry_bas

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv86[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv92[ebp], eax
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Sentry_bas:

; 78   :             }
; 79   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv93 = -212						; size = 4
tv87 = -208						; size = 4
tv73 = -208						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@Sentry_bas

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv87[ebp], ecx
	mov	edx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv87[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Sentry_bas:

; 72   :             }
; 73   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
_TEXT	SEGMENT
__Invoker_proc$ = -48					; size = 4
__Decay_copied$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Fx$ = 8						; size = 4
??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z PROC ; std::thread::thread<<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,void>, COMDAT
; _this$ = ecx

; 52   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4

; 53   :         using _Tuple                 = tuple<decay_t<_Fn>, decay_t<_Args>...>;
; 54   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

	push	4
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	call	?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR __Fx$[ebp]
	push	eax
	call	??$forward@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@YA$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@AAV1@@Z ; std::forward<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	push	ecx
	call	??$make_unique@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@0@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ; std::make_unique<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,0>
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 55   :         constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{});

	mov	DWORD PTR __Invoker_proc$[ebp], OFFSET ??$_Invoke@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@$0A@@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,0>

; 56   :         _Thr._Hnd =

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	call	?get@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::get
	push	eax
	mov	ecx, DWORD PTR __Invoker_proc$[ebp]
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp___beginthreadex
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@thread

; 59   :             _Thr._Id = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	push	6
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error

; 61   :         } else { // ownership transferred to the thread

	jmp	SHORT $LN3@thread
$LN2@thread:

; 62   :             (void) _Decay_copied.release();

	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	call	?release@?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@2@XZ ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::release
$LN3@thread:

; 63   :         }
; 64   :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	call	??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::~unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >
	mov	eax, DWORD PTR _this$[ebp]
$LN4@thread:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@thread
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN9@thread:
	DD	1
	DD	$LN8@thread
$LN8@thread:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN6@thread
$LN6@thread:
	DB	95					; 0000005fH
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z$0:
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	jmp	??1?$unique_ptr@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@U?$default_delete@V?$tuple@V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >::~unique_ptr<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> >,std::default_delete<std::tuple<<lambda_7ec1dc920a35512b9dcd3a4255af04b6> > > >
__ehhandler$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ENDP ; std::thread::thread<<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,void>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT ??0<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QAE@AAVmutex@std@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<m1>$ = 8						; size = 4
_<m2>$ = 12						; size = 4
??0<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QAE@AAVmutex@std@@0@Z PROC ; <lambda_7ec1dc920a35512b9dcd3a4255af04b6>::<lambda_7ec1dc920a35512b9dcd3a4255af04b6>, COMDAT
; _this$ = ecx

; 61   : 		});

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _<m1>$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _<m2>$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QAE@AAVmutex@std@@0@Z ENDP ; <lambda_7ec1dc920a35512b9dcd3a4255af04b6>::<lambda_7ec1dc920a35512b9dcd3a4255af04b6>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT ??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ
_TEXT	SEGMENT
$T2 = -268						; size = 4
$T3 = -256						; size = 8
_guard2$ = -48						; size = 4
_guard1$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ PROC ; <lambda_7ec1dc920a35512b9dcd3a4255af04b6>::operator(), COMDAT
; _this$ = ecx

; 61   : 		});

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4

; 54   : 		std::lock_guard<std::mutex> guard1(m1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _guard1$[ebp]
	call	??0?$lock_guard@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ; std::lock_guard<std::mutex>::lock_guard<std::mutex>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 55   : 		std::lock_guard<std::mutex> guard2(m2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR _guard2$[ebp]
	call	??0?$lock_guard@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ; std::lock_guard<std::mutex>::lock_guard<std::mutex>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 56   : 		std::cout << "2. Acquiring m2" << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0BA@MJAPHBEP@2?4?5Acquiring?5m2@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 57   : 		//m2.lock();
; 58   : 		std::this_thread::sleep_for(std::chrono::milliseconds(10));

	mov	DWORD PTR $T2[ebp], 10			; 0000000aH
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>
	push	eax
	call	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
	add	esp, 4

; 59   : 		std::cout << "2. Acquiring m1" << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0BA@OCCCCCIM@2?4?5Acquiring?5m1@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 61   : 		});

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _guard2$[ebp]
	call	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _guard1$[ebp]
	call	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@operator:
	DD	2
	DD	$LN8@operator
$LN8@operator:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN5@operator
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN6@operator
$LN6@operator:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	50					; 00000032H
	DB	0
$LN5@operator:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ$0:
	lea	ecx, DWORD PTR _guard1$[ebp]
	jmp	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
__unwindfunclet$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ$1:
	lea	ecx, DWORD PTR _guard2$[ebp]
	jmp	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
__ehhandler$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??R<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QBEXXZ ENDP ; <lambda_7ec1dc920a35512b9dcd3a4255af04b6>::operator()
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
_TEXT	SEGMENT
__Invoker_proc$ = -48					; size = 4
__Decay_copied$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Fx$ = 8						; size = 4
??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z PROC ; std::thread::thread<<lambda_463439238b6f21205974601aef348251>,void>, COMDAT
; _this$ = ecx

; 52   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4

; 53   :         using _Tuple                 = tuple<decay_t<_Fn>, decay_t<_Args>...>;
; 54   :         auto _Decay_copied           = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);

	push	4
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	call	?__autoclassinit2@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR __Fx$[ebp]
	push	eax
	call	??$forward@V<lambda_463439238b6f21205974601aef348251>@@@std@@YA$$QAV<lambda_463439238b6f21205974601aef348251>@@AAV1@@Z ; std::forward<<lambda_463439238b6f21205974601aef348251> >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	push	ecx
	call	??$make_unique@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@V<lambda_463439238b6f21205974601aef348251>@@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@0@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ; std::make_unique<std::tuple<<lambda_463439238b6f21205974601aef348251> >,<lambda_463439238b6f21205974601aef348251>,0>
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 55   :         constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{});

	mov	DWORD PTR __Invoker_proc$[ebp], OFFSET ??$_Invoke@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@$0A@@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<<lambda_463439238b6f21205974601aef348251> >,0>

; 56   :         _Thr._Hnd =

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	push	0
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	call	?get@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QBEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::get
	push	eax
	mov	ecx, DWORD PTR __Invoker_proc$[ebp]
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp___beginthreadex
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@thread

; 59   :             _Thr._Id = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	push	6
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error

; 61   :         } else { // ownership transferred to the thread

	jmp	SHORT $LN3@thread
$LN2@thread:

; 62   :             (void) _Decay_copied.release();

	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	call	?release@?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAEPAV?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@2@XZ ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::release
$LN3@thread:

; 63   :         }
; 64   :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	call	??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::~unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >
	mov	eax, DWORD PTR _this$[ebp]
$LN4@thread:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@thread
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN9@thread:
	DD	1
	DD	$LN8@thread
$LN8@thread:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN6@thread
$LN6@thread:
	DB	95					; 0000005fH
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z$0:
	lea	ecx, DWORD PTR __Decay_copied$[ebp]
	jmp	??1?$unique_ptr@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@U?$default_delete@V?$tuple@V<lambda_463439238b6f21205974601aef348251>@@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >::~unique_ptr<std::tuple<<lambda_463439238b6f21205974601aef348251> >,std::default_delete<std::tuple<<lambda_463439238b6f21205974601aef348251> > > >
__ehhandler$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ENDP ; std::thread::thread<<lambda_463439238b6f21205974601aef348251>,void>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z
_TEXT	SEGMENT
$T1 = -220						; size = 8
$T2 = -204						; size = 8
__Rel_time$ = 8						; size = 4
??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z PROC ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >, COMDAT

; 161  :     inline void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time) { // sleep for duration

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4

; 162  :         sleep_until(chrono::steady_clock::now() + _Rel_time);

	mov	eax, DWORD PTR __Rel_time$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$?HUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@_JU?$ratio@$00$0DOI@@2@@chrono@std@@YA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@ABV201@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::operator+<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
	add	esp, 12					; 0000000cH
	push	eax
	call	??$sleep_until@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@this_thread@std@@YAXABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@1@@Z ; std::this_thread::sleep_until<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
	add	esp, 4

; 163  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ENDP ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 77   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 901  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 902  :     _Ostr.put(_Ostr.widen('\n'));

	mov	esi, esp
	push	10					; 0000000aH
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 903  :     _Ostr.flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 904  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]

; 905  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -356						; size = 8
tv343 = -348						; size = 8
tv291 = -344						; size = 4
tv288 = -344						; size = 8
tv286 = -344						; size = 4
tv329 = -340						; size = 8
tv290 = -340						; size = 4
tv285 = -340						; size = 4
tv287 = -336						; size = 4
tv137 = -336						; size = 4
tv289 = -333						; size = 1
tv284 = -333						; size = 1
$T2 = -328						; size = 4
$T3 = -316						; size = 4
$T4 = -304						; size = 4
$T5 = -292						; size = 4
$T6 = -280						; size = 4
__Ok$ = -76						; size = 8
__Pad$ = -60						; size = 8
__Count$ = -44						; size = 8
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 696  :     const char* _Val) { // insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-356]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ecx, OFFSET __4FF445BD_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 697  :     using _Elem = char;
; 698  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 699  : 
; 700  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 701  :     streamsize _Count        = (streamsize) _Traits::length(_Val); // may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIQBD@Z	; std::char_traits<char>::length
	add	esp, 4
	xor	ecx, ecx
	mov	DWORD PTR __Count$[ebp], eax
	mov	DWORD PTR __Count$[ebp+4], ecx

; 702  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv329[ebp], eax
	mov	DWORD PTR tv329[ebp+4], edx
	cmp	DWORD PTR tv329[ebp+4], 0
	jl	SHORT $LN17@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR tv329[ebp], 0
	jbe	SHORT $LN17@operator
$LN24@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv343[ebp], eax
	mov	DWORD PTR tv343[ebp+4], edx
	mov	eax, DWORD PTR tv343[ebp+4]
	cmp	eax, DWORD PTR __Count$[ebp+4]
	jl	SHORT $LN17@operator
	jg	SHORT $LN25@operator
	mov	ecx, DWORD PTR tv343[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN17@operator
$LN25@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Count$[ebp]
	sbb	edx, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR tv135[ebp], eax
	mov	DWORD PTR tv135[ebp+4], edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv135[ebp], xmm0
$LN18@operator:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR __Pad$[ebp], ecx
	mov	edx, DWORD PTR tv135[ebp+4]
	mov	DWORD PTR __Pad$[ebp+4], edx

; 703  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 704  : 
; 705  :     if (!_Ok) {

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@operator

; 706  :         _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 707  :     } else { // state okay, insert

	jmp	$LN9@operator
$LN8@operator:

; 708  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 709  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv137[ebp], eax
	mov	eax, DWORD PTR tv137[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator

; 710  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN11@operator
	jg	SHORT $LN26@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN11@operator
$LN26@operator:

; 711  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv284[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv285[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv284[ebp]
	push	eax
	mov	ecx, DWORD PTR tv285[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv286[ebp], eax
	mov	ecx, DWORD PTR tv286[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@operator

; 712  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 713  :                     break;

	jmp	SHORT $LN11@operator
$LN12@operator:

; 714  :                 }
; 715  :             }

	jmp	$LN2@operator
$LN11@operator:

; 716  :         }
; 717  : 
; 718  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN13@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv287[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv288[ebp], eax
	mov	DWORD PTR tv288[ebp+4], edx
	mov	eax, DWORD PTR tv288[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jne	SHORT $LN27@operator
	mov	ecx, DWORD PTR tv288[ebp+4]
	cmp	ecx, DWORD PTR __Count$[ebp+4]
	je	SHORT $LN13@operator
$LN27@operator:

; 719  :             _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN13@operator:

; 720  :         }
; 721  : 
; 722  :         if (_State == ios_base::goodbit) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN14@operator

; 723  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN14@operator
	jg	SHORT $LN28@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN14@operator
$LN28@operator:

; 724  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv289[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv290[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv289[ebp]
	push	eax
	mov	ecx, DWORD PTR tv290[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv291[ebp], eax
	mov	ecx, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@operator

; 725  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 726  :                     break;

	jmp	SHORT $LN14@operator
$LN15@operator:

; 727  :                 }
; 728  :             }

	jmp	$LN5@operator
$LN14@operator:

; 729  :         }
; 730  : 
; 731  :         _Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 732  :         _CATCH_IO_(ios_base, _Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN23@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN9@operator
$LN23@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 733  :     }
; 734  : 
; 735  :     _Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 736  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 737  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN32@operator:
	DD	1
	DD	$LN31@operator
$LN31@operator:
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN29@operator
$LN29@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT ??0<lambda_463439238b6f21205974601aef348251>@@QAE@AAVmutex@std@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<m1>$ = 8						; size = 4
_<m2>$ = 12						; size = 4
??0<lambda_463439238b6f21205974601aef348251>@@QAE@AAVmutex@std@@0@Z PROC ; <lambda_463439238b6f21205974601aef348251>::<lambda_463439238b6f21205974601aef348251>, COMDAT
; _this$ = ecx

; 52   : 		});

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _<m1>$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _<m2>$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0<lambda_463439238b6f21205974601aef348251>@@QAE@AAVmutex@std@@0@Z ENDP ; <lambda_463439238b6f21205974601aef348251>::<lambda_463439238b6f21205974601aef348251>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT ??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ
_TEXT	SEGMENT
$T2 = -268						; size = 4
$T3 = -256						; size = 8
_guard2$ = -48						; size = 4
_guard1$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ PROC ; <lambda_463439238b6f21205974601aef348251>::operator(), COMDAT
; _this$ = ecx

; 52   : 		});

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4

; 45   : 		std::lock_guard<std::mutex> guard1(m1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _guard1$[ebp]
	call	??0?$lock_guard@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ; std::lock_guard<std::mutex>::lock_guard<std::mutex>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		std::lock_guard<std::mutex> guard2(m2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR _guard2$[ebp]
	call	??0?$lock_guard@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ; std::lock_guard<std::mutex>::lock_guard<std::mutex>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 47   : 		std::cout << "1. Acquiring m1." << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0BB@LMHBLPIB@1?4?5Acquiring?5m1?4@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 48   : 		//m1.lock();
; 49   : 		std::this_thread::sleep_for(std::chrono::milliseconds(10));

	mov	DWORD PTR $T2[ebp], 10			; 0000000aH
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?0HX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABH@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int,void>
	push	eax
	call	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
	add	esp, 4

; 50   : 		std::cout << "1. Acquiring m2" << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0BA@OAMHMFLN@1?4?5Acquiring?5m2@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 52   : 		});

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _guard2$[ebp]
	call	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _guard1$[ebp]
	call	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@operator:
	DD	2
	DD	$LN8@operator
$LN8@operator:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN5@operator
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN6@operator
$LN6@operator:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	50					; 00000032H
	DB	0
$LN5@operator:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ$0:
	lea	ecx, DWORD PTR _guard1$[ebp]
	jmp	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
__unwindfunclet$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ$1:
	lea	ecx, DWORD PTR _guard2$[ebp]
	jmp	??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
__ehhandler$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??R<lambda_463439238b6f21205974601aef348251>@@QBEXXZ ENDP ; <lambda_463439238b6f21205974601aef348251>::operator()
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT _main
_TEXT	SEGMENT
$T2 = -404						; size = 8
$T3 = -388						; size = 8
_T$ = -180						; size = 16
_t2$ = -156						; size = 8
_t1$ = -140						; size = 8
_m2$ = -124						; size = 48
_m1$ = -68						; size = 48
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 41   : int main() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-408]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4

; 42   : 	std::mutex m1;

	lea	ecx, DWORD PTR _m1$[ebp]
	call	??0mutex@std@@QAE@XZ			; std::mutex::mutex
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 43   : 	std::mutex m2;

	lea	ecx, DWORD PTR _m2$[ebp]
	call	??0mutex@std@@QAE@XZ			; std::mutex::mutex
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 44   : 	std::thread t1([&m1, &m2] {

	lea	eax, DWORD PTR _m2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m1$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0<lambda_463439238b6f21205974601aef348251>@@QAE@AAVmutex@std@@0@Z ; <lambda_463439238b6f21205974601aef348251>::<lambda_463439238b6f21205974601aef348251>
	push	eax
	lea	ecx, DWORD PTR _t1$[ebp]
	call	??$?0V<lambda_463439238b6f21205974601aef348251>@@$$VX@thread@std@@QAE@$$QAV<lambda_463439238b6f21205974601aef348251>@@@Z ; std::thread::thread<<lambda_463439238b6f21205974601aef348251>,void>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 45   : 		std::lock_guard<std::mutex> guard1(m1);
; 46   : 		std::lock_guard<std::mutex> guard2(m2);
; 47   : 		std::cout << "1. Acquiring m1." << std::endl;
; 48   : 		//m1.lock();
; 49   : 		std::this_thread::sleep_for(std::chrono::milliseconds(10));
; 50   : 		std::cout << "1. Acquiring m2" << std::endl;
; 51   : 		//m2.lock();
; 52   : 		});
; 53   : 	std::thread t2([&m1, &m2] {

	lea	eax, DWORD PTR _m2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m1$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@QAE@AAVmutex@std@@0@Z ; <lambda_7ec1dc920a35512b9dcd3a4255af04b6>::<lambda_7ec1dc920a35512b9dcd3a4255af04b6>
	push	eax
	lea	ecx, DWORD PTR _t2$[ebp]
	call	??$?0V<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@$$VX@thread@std@@QAE@$$QAV<lambda_7ec1dc920a35512b9dcd3a4255af04b6>@@@Z ; std::thread::thread<<lambda_7ec1dc920a35512b9dcd3a4255af04b6>,void>
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 54   : 		std::lock_guard<std::mutex> guard1(m1);
; 55   : 		std::lock_guard<std::mutex> guard2(m2);
; 56   : 		std::cout << "2. Acquiring m2" << std::endl;
; 57   : 		//m2.lock();
; 58   : 		std::this_thread::sleep_for(std::chrono::milliseconds(10));
; 59   : 		std::cout << "2. Acquiring m1" << std::endl;
; 60   : 		//m1.lock();
; 61   : 		});
; 62   : 
; 63   : 	t1.join();

	lea	ecx, DWORD PTR _t1$[ebp]
	call	?join@thread@std@@QAEXXZ		; std::thread::join

; 64   : 	t2.join();

	lea	ecx, DWORD PTR _t2$[ebp]
	call	?join@thread@std@@QAEXXZ		; std::thread::join

; 65   : 
; 66   : 
; 67   : 	C1 T;

	lea	ecx, DWORD PTR _T$[ebp]
	call	??0C1@@QAE@XZ				; C1::C1
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 68   : 	std::cout << sizeof(C1);

	mov	esi, esp
	push	16					; 00000010H
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 69   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _T$[ebp]
	call	??1C1@@QAE@XZ				; C1::~C1
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _t2$[ebp]
	call	??1thread@std@@QAE@XZ			; std::thread::~thread
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _t1$[ebp]
	call	??1thread@std@@QAE@XZ			; std::thread::~thread
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m2$[ebp]
	call	??1mutex@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m1$[ebp]
	call	??1mutex@std@@QAE@XZ
	xor	eax, eax
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@main
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 408				; 00000198H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@main:
	DD	5
	DD	$LN14@main
$LN14@main:
	DD	-68					; ffffffbcH
	DD	48					; 00000030H
	DD	$LN8@main
	DD	-124					; ffffff84H
	DD	48					; 00000030H
	DD	$LN9@main
	DD	-140					; ffffff74H
	DD	8
	DD	$LN10@main
	DD	-156					; ffffff64H
	DD	8
	DD	$LN11@main
	DD	-180					; ffffff4cH
	DD	16					; 00000010H
	DD	$LN12@main
$LN12@main:
	DB	84					; 00000054H
	DB	0
$LN11@main:
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$LN10@main:
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$LN9@main:
	DB	109					; 0000006dH
	DB	50					; 00000032H
	DB	0
$LN8@main:
	DB	109					; 0000006dH
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
	lea	ecx, DWORD PTR _m1$[ebp]
	jmp	??1mutex@std@@QAE@XZ
__unwindfunclet$_main$1:
	lea	ecx, DWORD PTR _m2$[ebp]
	jmp	??1mutex@std@@QAE@XZ
__unwindfunclet$_main$2:
	lea	ecx, DWORD PTR _t1$[ebp]
	jmp	??1thread@std@@QAE@XZ			; std::thread::~thread
__unwindfunclet$_main$3:
	lea	ecx, DWORD PTR _t2$[ebp]
	jmp	??1thread@std@@QAE@XZ			; std::thread::~thread
__unwindfunclet$_main$4:
	lea	ecx, DWORD PTR _T$[ebp]
	jmp	??1C1@@QAE@XZ				; C1::~C1
__ehhandler$_main:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-412]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT ??1C1@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1C1@@QAE@XZ PROC					; C1::~C1, COMDAT
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1C1@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7C1@@6B@

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1C1@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1C1@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1C1@@QAE@XZ ENDP					; C1::~C1
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT ??0C1@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0C1@@QAE@XZ PROC					; C1::C1, COMDAT
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7C1@@6B@

; 35   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0C1@@QAE@XZ ENDP					; C1::C1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT ?T2@C1@@EAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?T2@C1@@EAEXXZ PROC					; C1::T2, COMDAT
; _this$ = ecx

; 14   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4

; 15   : 
; 16   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?T2@C1@@EAEXXZ ENDP					; C1::T2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.h
;	COMDAT ?T1@C1@@EAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?T1@C1@@EAEXXZ PROC					; C1::T1, COMDAT
; _this$ = ecx

; 10   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1D59C813_TestTHREAD@h
	call	@__CheckForDebuggerJustMyCode@4

; 11   : 
; 12   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?T1@C1@@EAEXXZ ENDP					; C1::T1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\mutex
;	COMDAT ??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ PROC		; std::lock_guard<std::mutex>::~lock_guard<std::mutex>, COMDAT
; _this$ = ecx

; 444  :     ~lock_guard() noexcept { // unlock

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3A9BB828_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 445  :         _MyMutex.unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?unlock@_Mutex_base@std@@QAEXXZ		; std::_Mutex_base::unlock

; 446  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$lock_guard@Vmutex@std@@@std@@QAE@XZ ENDP		; std::lock_guard<std::mutex>::~lock_guard<std::mutex>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\mutex
;	COMDAT ??0?$lock_guard@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Mtx$ = 8						; size = 4
??0?$lock_guard@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z PROC ; std::lock_guard<std::mutex>::lock_guard<std::mutex>, COMDAT
; _this$ = ecx

; 437  :     explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3A9BB828_mutex
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mtx$[ebp]
	mov	DWORD PTR [eax], ecx

; 438  :         _MyMutex.lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?lock@_Mutex_base@std@@QAEXXZ		; std::_Mutex_base::lock

; 439  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$lock_guard@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ENDP ; std::lock_guard<std::mutex>::lock_guard<std::mutex>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1mutex@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1mutex@std@@QAE@XZ PROC				; std::mutex::~mutex, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Mutex_base@std@@QAE@XZ		; std::_Mutex_base::~_Mutex_base
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1mutex@std@@QAE@XZ ENDP				; std::mutex::~mutex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\mutex
;	COMDAT ??0mutex@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0mutex@std@@QAE@XZ PROC				; std::mutex::mutex, COMDAT
; _this$ = ecx

; 84   :     /* constexpr */ mutex() noexcept // TRANSITION

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0mutex@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3A9BB828_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 85   :         : _Mutex_base() { // default construct

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Mutex_base@std@@QAE@H@Z		; std::_Mutex_base::_Mutex_base

; 86   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0mutex@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0mutex@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0mutex@std@@QAE@XZ ENDP				; std::mutex::mutex
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\mutex
;	COMDAT ?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ PROC ; std::_Mutex_base::_Mymtx, COMDAT
; _this$ = ecx

; 77   :     _Mtx_t _Mymtx() noexcept { // get pointer to _Mtx_internal_imp_t inside _Mtx_storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3A9BB828_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 78   :         return reinterpret_cast<_Mtx_t>(&_Mtx_storage);

	mov	eax, DWORD PTR _this$[ebp]

; 79   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ENDP ; std::_Mutex_base::_Mymtx
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\mutex
;	COMDAT ?unlock@_Mutex_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?unlock@_Mutex_base@std@@QAEXXZ PROC			; std::_Mutex_base::unlock, COMDAT
; _this$ = ecx

; 61   :     void unlock() { // unlock the mutex

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3A9BB828_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 62   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	call	__Mtx_unlock
	add	esp, 4
	push	eax
	call	?_Check_C_return@std@@YAHH@Z		; std::_Check_C_return
	add	esp, 4

; 63   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?unlock@_Mutex_base@std@@QAEXXZ ENDP			; std::_Mutex_base::unlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\mutex
;	COMDAT ?lock@_Mutex_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?lock@_Mutex_base@std@@QAEXXZ PROC			; std::_Mutex_base::lock, COMDAT
; _this$ = ecx

; 45   :     void lock() { // lock the mutex

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3A9BB828_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 46   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	call	__Mtx_lock
	add	esp, 4
	push	eax
	call	?_Check_C_return@std@@YAHH@Z		; std::_Check_C_return
	add	esp, 4

; 47   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?lock@_Mutex_base@std@@QAEXXZ ENDP			; std::_Mutex_base::lock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\mutex
;	COMDAT ??1_Mutex_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Mutex_base@std@@QAE@XZ PROC				; std::_Mutex_base::~_Mutex_base, COMDAT
; _this$ = ecx

; 38   :     ~_Mutex_base() noexcept { // clean up

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Mutex_base@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3A9BB828_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 39   :         _Mtx_destroy_in_situ(_Mymtx());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	call	__Mtx_destroy_in_situ
	add	esp, 4

; 40   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Mutex_base@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Mutex_base@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Mutex_base@std@@QAE@XZ ENDP				; std::_Mutex_base::~_Mutex_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\mutex
;	COMDAT ??0_Mutex_base@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Flags$ = 8						; size = 4
??0_Mutex_base@std@@QAE@H@Z PROC			; std::_Mutex_base::_Mutex_base, COMDAT
; _this$ = ecx

; 34   :     _Mutex_base(int _Flags = 0) noexcept { // construct with _Flags

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Mutex_base@std@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __3A9BB828_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 35   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	mov	eax, DWORD PTR __Flags$[ebp]
	or	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	call	__Mtx_init_in_situ
	add	esp, 8

; 36   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0_Mutex_base@std@@QAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Mutex_base@std@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Mutex_base@std@@QAE@H@Z ENDP			; std::_Mutex_base::_Mutex_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ?join@thread@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
?join@thread@std@@QAEXXZ PROC				; std::thread::join, COMDAT
; _this$ = ecx

; 96   :     void join() { // join thread

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4

; 97   :         if (!joinable()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?joinable@thread@std@@QBE_NXZ		; std::thread::joinable
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@join

; 98   :             _Throw_Cpp_error(_INVALID_ARGUMENT);

	push	1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN2@join:

; 99   :         }
; 100  : 
; 101  :         if (_Thr._Id == _Thrd_id()) {

	call	__Thrd_id
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN3@join

; 102  :             _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	push	5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN3@join:

; 103  :         }
; 104  : 
; 105  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	__Thrd_join
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@join

; 106  :             _Throw_Cpp_error(_NO_SUCH_PROCESS);

	push	2
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN4@join:

; 107  :         }
; 108  : 
; 109  :         _Thr = {};

	xor	eax, eax
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@join:

; 110  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?join@thread@std@@QAEXXZ ENDP				; std::thread::join
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ?joinable@thread@std@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -220						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?joinable@thread@std@@QBE_NXZ PROC			; std::thread::joinable, COMDAT
; _this$ = ecx

; 92   :     _NODISCARD bool joinable() const noexcept { // return true if this thread can be joined

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?joinable@thread@std@@QBE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4

; 93   :         return _Thr._Id != 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@joinable
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@joinable
$LN3@joinable:
	mov	DWORD PTR tv67[ebp], 0
$LN4@joinable:
	mov	al, BYTE PTR tv67[ebp]

; 94   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?joinable@thread@std@@QBE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?joinable@thread@std@@QBE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?joinable@thread@std@@QBE_NXZ ENDP			; std::thread::joinable
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thread
;	COMDAT ??1thread@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1thread@std@@QAE@XZ PROC				; std::thread::~thread, COMDAT
; _this$ = ecx

; 66   :     ~thread() noexcept { // clean up

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1thread@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7D9260A7_thread
	call	@__CheckForDebuggerJustMyCode@4

; 67   :         if (joinable()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?joinable@thread@std@@QBE_NXZ		; std::thread::joinable
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@thread

; 68   :             _STD terminate();

	mov	esi, esp
	call	DWORD PTR __imp__terminate
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@thread:

; 69   :         }
; 70   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1thread@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1thread@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1thread@std@@QAE@XZ ENDP				; std::thread::~thread
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\thr\xthreads.h
;	COMDAT ?_Check_C_return@std@@YAHH@Z
_TEXT	SEGMENT
__Res$ = 8						; size = 4
?_Check_C_return@std@@YAHH@Z PROC			; std::_Check_C_return, COMDAT

; 136  : inline int _Check_C_return(int _Res) { // throw exception on failure

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7081408F_xthreads@h
	call	@__CheckForDebuggerJustMyCode@4

; 137  :     if (_Res != _Thrd_success) {

	cmp	DWORD PTR __Res$[ebp], 0
	je	SHORT $LN2@Check_C_re

; 138  :         _Throw_C_error(_Res);

	mov	eax, DWORD PTR __Res$[ebp]
	push	eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
$LN2@Check_C_re:

; 139  :     }
; 140  : 
; 141  :     return _Res;

	mov	eax, DWORD PTR __Res$[ebp]
$LN3@Check_C_re:

; 142  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Check_C_return@std@@YAHH@Z ENDP			; std::_Check_C_return
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xstring
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 373  :     _NODISCARD static constexpr int_type eof() noexcept { // return end-of-file metacharacter

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eof@?$char_traits@D@std@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __83DAEB48_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 374  :         return EOF;

	or	eax, -1

; 375  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?eof@?$char_traits@D@std@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eof@?$char_traits@D@std@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xstring
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 365  :         const int_type& _Left, const int_type& _Right) noexcept { // test for metacharacter equality

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __83DAEB48_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 366  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	mov	al, BYTE PTR tv65[ebp]

; 367  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\xstring
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 298  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const char* const _First) noexcept { // strengthened

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?length@?$char_traits@D@std@@SAIQBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __83DAEB48_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 299  :         // find length of null-terminated string
; 300  : #if _HAS_CXX17
; 301  :         return __builtin_strlen(_First);
; 302  : #else // _HAS_CXX17
; 303  :         return _CSTD strlen(_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 304  : #endif // _HAS_CXX17
; 305  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?length@?$char_traits@D@std@@SAIQBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?length@?$char_traits@D@std@@SAIQBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ PROC ; std::chrono::duration<double,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 87   :         _NODISCARD constexpr _Rep count() const { // get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 88   :             return _MyRep;

	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR [eax]

; 89   :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@NU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBENXZ ENDP ; std::chrono::duration<double,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT
; _this$ = ecx

; 87   :         _NODISCARD constexpr _Rep count() const { // get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 88   :             return _MyRep;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 89   :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::count, COMDAT
; _this$ = ecx

; 87   :         _NODISCARD constexpr _Rep count() const { // get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 88   :             return _MyRep;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 89   :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ PROC ; std::chrono::duration<double,std::ratio<1,1> >::count, COMDAT
; _this$ = ecx

; 87   :         _NODISCARD constexpr _Rep count() const { // get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 88   :             return _MyRep;

	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR [eax]

; 89   :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@NU?$ratio@$00$00@std@@@chrono@std@@QBENXZ ENDP ; std::chrono::duration<double,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 77   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 187  :         _NODISCARD constexpr _Duration time_since_epoch() const { // get duration from epoch

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 188  :             return _MyDur;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 189  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Other$ = 8						; size = 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 180  :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=, COMDAT
; _this$ = ecx

; 122  :         _CONSTEXPR17 duration& operator-=(const duration& _Right) { // subtract _Right from rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 123  :             _MyRep -= _Right._MyRep;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	sbb	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 124  :             return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 125  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=, COMDAT
; _this$ = ecx

; 117  :         _CONSTEXPR17 duration& operator+=(const duration& _Right) { // add _Right to rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 118  :             _MyRep += _Right._MyRep;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	add	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	adc	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 119  :             return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 120  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 87   :         _NODISCARD constexpr _Rep count() const { // get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 88   :             return _MyRep;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 89   :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
$T2 = -296						; size = 8
$T3 = -280						; size = 8
__Part$ = -72						; size = 8
__Whole$ = -56						; size = 8
__Ctr$ = -40						; size = 8
__Freq$ = -24						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT

; 574  :         _NODISCARD static time_point now() noexcept { // get current time

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 575  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

	call	__Query_perf_frequency
	mov	DWORD PTR __Freq$[ebp], eax
	mov	DWORD PTR __Freq$[ebp+4], edx

; 576  :             const long long _Ctr  = _Query_perf_counter();

	call	__Query_perf_counter
	mov	DWORD PTR __Ctr$[ebp], eax
	mov	DWORD PTR __Ctr$[ebp+4], edx

; 577  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 578  :             const long long _Whole = (_Ctr / _Freq) * period::den;

	mov	eax, DWORD PTR __Freq$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Freq$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ctr$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Ctr$[ebp]
	push	eax
	call	__alldiv
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR __Whole$[ebp], eax
	mov	DWORD PTR __Whole$[ebp+4], edx

; 579  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

	mov	eax, DWORD PTR __Freq$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Freq$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ctr$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Ctr$[ebp]
	push	eax
	call	__allrem
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR __Freq$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR __Freq$[ebp]
	push	ecx
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR __Part$[ebp], eax
	mov	DWORD PTR __Part$[ebp+4], edx

; 580  :             return time_point(duration(_Whole + _Part));

	mov	eax, DWORD PTR __Whole$[ebp]
	add	eax, DWORD PTR __Part$[ebp]
	mov	ecx, DWORD PTR __Whole$[ebp+4]
	adc	ecx, DWORD PTR __Part$[ebp+4]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 581  :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-304]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 77   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 187  :         _NODISCARD constexpr _Duration time_since_epoch() const { // get duration from epoch

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 188  :             return _MyDur;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 189  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Other$ = 8						; size = 4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT
; _this$ = ecx

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 180  :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT
; _this$ = ecx

; 87   :         _NODISCARD constexpr _Rep count() const { // get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 88   :             return _MyRep;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 89   :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.21.27702\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
$T2 = -232						; size = 8
$T3 = -216						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 554  :         _NODISCARD static time_point now() noexcept { // get current time

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __7E9C1215_chrono
	call	@__CheckForDebuggerJustMyCode@4

; 555  :             return time_point(duration(_Xtime_get_ticks()));

	call	__Xtime_get_ticks
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 556  :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-240]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __873FF162_TestTHREAD@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Class\6.0\TTx\TTx\TestTHREAD.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __873FF162_TestTHREAD@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
